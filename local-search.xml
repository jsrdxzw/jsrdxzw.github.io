<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>session一致性</title>
    <link href="/2021/07/26/session/"/>
    <url>/2021/07/26/session/</url>
    
    <content type="html"><![CDATA[<h3 id="session在分布式环境下的问题"><a href="#session在分布式环境下的问题" class="headerlink" title="session在分布式环境下的问题"></a>session在分布式环境下的问题</h3><p>Session在集群情况下，可能会发生不一致的问题，即Session不能在多机器共享</p><p><img src="/img/session.png" alt="Session不一致问题"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-使用Nginx的ip-hash-保证同一个ip请求同一个实例"><a href="#1-使用Nginx的ip-hash-保证同一个ip请求同一个实例" class="headerlink" title="1. 使用Nginx的ip_hash 保证同一个ip请求同一个实例"></a>1. 使用Nginx的<code>ip_hash</code> 保证同一个ip请求同一个实例</h4><p>优点:</p><ul><li>配置简单，不入侵应用，不需要额外修改代码</li></ul><p>缺点:</p><ul><li>服务器重启，Session会丢失，因为Session本质上保存在服务器内存中</li><li>单点负载，故障风险</li></ul><h4 id="2-使用Redis统一保存Session"><a href="#2-使用Redis统一保存Session" class="headerlink" title="2. 使用Redis统一保存Session"></a>2. 使用Redis统一保存Session</h4><p>优点:</p><ul><li>能适应各种负载均衡策略 </li><li>服务器重启或者宕机不会造成Session丢失 </li><li>扩展能力强</li><li>适合大集群数量使用</li></ul><p>使用<code>Spring Session</code>可以非常方便的实现Redis管理Session</p><ol><li><p>引入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置redis</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure></li><li><p>添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableRedisHttpSession</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringApplication</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>源码分析</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 其实就是自定义了一个filter</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionRepositoryFilter</span>&lt;<span class="hljs-title">S</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Session</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// 请求中只会调用一次</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        request.setAttribute(SESSION_REPOSITORY_ATTR, <span class="hljs-keyword">this</span>.sessionRepository);<br><br>        SessionRepositoryRequestWrapper wrappedRequest = <span class="hljs-keyword">new</span> SessionRepositoryRequestWrapper(<br>                request, response, <span class="hljs-keyword">this</span>.servletContext);<br>        SessionRepositoryResponseWrapper wrappedResponse = <span class="hljs-keyword">new</span> SessionRepositoryResponseWrapper(<br>                wrappedRequest, response);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            filterChain.doFilter(wrappedRequest, wrappedResponse);<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 这里保存到redis</span><br>            wrappedRequest.commitSession();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关注 <code>SessionRepositoryRequestWrapper.getSession()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建了一个session，但是还没有保存到Redis</span><br>S session = SessionRepositoryFilter.<span class="hljs-keyword">this</span>.sessionRepository.createSession();<br><span class="hljs-comment">// wrappedRequest.commitSession() 里面的方法</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commitSession</span><span class="hljs-params">()</span> </span>&#123;<br>    HttpSessionWrapper wrappedSession = getCurrentSession();<br>        <span class="hljs-keyword">if</span> (wrappedSession == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (isInvalidateClientSession()) &#123;<br>                SessionRepositoryFilter.<span class="hljs-keyword">this</span>.httpSessionIdResolver.expireSession(<span class="hljs-keyword">this</span>,<br>                <span class="hljs-keyword">this</span>.response);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            S session = wrappedSession.getSession();<br>            clearRequestedSessionCache();<br>            <span class="hljs-comment">// 在里面保存</span><br>            SessionRepositoryFilter.<span class="hljs-keyword">this</span>.sessionRepository.save(session);<br>            String sessionId = session.getId();<br>        <span class="hljs-keyword">if</span> (!isRequestedSessionIdValid()<br>            || !sessionId.equals(getRequestedSessionId())) &#123;<br>                SessionRepositoryFilter.<span class="hljs-keyword">this</span>.httpSessionIdResolver.setSessionId(<span class="hljs-keyword">this</span>,<br>                <span class="hljs-keyword">this</span>.response, sessionId);<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心保存方法</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveDelta</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.delta.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    String key = getSessionKey(getId());<br>    RedisSessionRepository.<span class="hljs-keyword">this</span>.sessionRedisOperations.opsForHash().putAll(key, <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-keyword">this</span>.delta));<br>    RedisSessionRepository.<span class="hljs-keyword">this</span>.sessionRedisOperations.expireAt(key,<br>            Date.from(Instant.ofEpochMilli(getLastAccessedTime().toEpochMilli())<br>                    .plusSeconds(getMaxInactiveInterval().getSeconds())));<br>    <span class="hljs-keyword">this</span>.delta.clear();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>session</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式id</title>
    <link href="/2021/07/25/global-id/"/>
    <url>/2021/07/25/global-id/</url>
    
    <content type="html"><![CDATA[<p>在数据库集群模式中，往往不能使用自增id，这时候可以在业务端生成全局唯一id。主要的方法有三种</p><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>直接使用jdk提供的UUID，优点是简单，缺点是非自增，无规律</p><h3 id="snowflake算法"><a href="#snowflake算法" class="headerlink" title="snowflake算法"></a>snowflake算法</h3><hr><p><img src="/img/snowflake.png" alt="雪花算法"></p><p>雪花算法主要结构如下</p><ul><li>1 位，不用。二进制中最高位为 1 的都是负数，但是我们生成的 id 一般都使用整数，所以这个最高位固定是<code>0</code></li><li>41 位，用来记录时间戳（毫秒）, 理论上可以支持69年左右</li><li>10 位，用来记录集群id和工作机器id<ul><li>可以部署在 <code>2^10 = 1024</code> 个节点，包括 5 位 datacenterId 和 5 位 workerId</li></ul></li><li>12 位序列号，用来记录同毫秒内产生的不同 id, 一毫秒同一个机器可以产生4096个id</li></ul><p>SnowFlake 可以保证：</p><p>同一台服务器所有生成的 id 按时间趋势递增</p><p>整个分布式系统内不会产生重复 id（因为有 datacenterId 和 workerId 来做区分）</p><p><code>依赖机器时钟，需要做时钟同步</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ntpdate -u ntp.api.bz<br></code></pre></td></tr></table></figure><p>主要的算法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">long</span> <span class="hljs-title">nextId</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> timestamp = timeGen();<br>    <span class="hljs-comment">// 获取当前时间戳如果小于上次时间戳，则表示时间戳获取出现异常</span><br>    <span class="hljs-keyword">if</span> (timestamp &lt; lastTimestamp) &#123;<br>        System.err.printf(<span class="hljs-string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>, lastTimestamp);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(String.format(<span class="hljs-string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>,<br>                lastTimestamp - timestamp));<br>    &#125;<br>    <span class="hljs-comment">// 获取当前时间戳如果等于上次时间戳</span><br>    <span class="hljs-comment">// 说明：还处在同一毫秒内，则在序列号加1；否则序列号赋值为0，从0开始。</span><br>    <span class="hljs-keyword">if</span> (lastTimestamp == timestamp) &#123;<br>        sequence = (sequence + <span class="hljs-number">1</span>) &amp; sequenceMask;<br>        <span class="hljs-comment">// sequence=0表示已经打到了4096，超过了边界，此时需要等待直到下一毫秒</span><br>        <span class="hljs-keyword">if</span> (sequence == <span class="hljs-number">0</span>) &#123;<br>            timestamp = tilNextMillis(lastTimestamp);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        sequence = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//将上次时间戳值刷新</span><br>    lastTimestamp = timestamp;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回结果：</span><br><span class="hljs-comment">     * (timestamp - twepoch) &lt;&lt; timestampLeftShift) 表示将时间戳减去初始时间戳，再左移相应位数</span><br><span class="hljs-comment">     * (datacenterId &lt;&lt; datacenterIdShift) 表示将数据id左移相应位数</span><br><span class="hljs-comment">     * (workerId &lt;&lt; workerIdShift) 表示将工作id左移相应位数</span><br><span class="hljs-comment">     * | 是按位或运算符，例如：x | y，只有当x，y都为0的时候结果才为0，其它情况结果都为1。</span><br><span class="hljs-comment">     * 因为个部分只有相应位上的值有意义，其它位上都是0，所以将各部分的值进行 | 运算就能得到最终拼接好的id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) |<br>            (datacenterId &lt;&lt; datacenterIdShift) |<br>            (workerId &lt;&lt; workerIdShift) |<br>            sequence;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的源码可以参考这里 <a href="https://github.com/jsrdxzw/improve-java/blob/master/id_worker/src/main/java/globalid/IdWorker.java">雪花算法源码</a></p><h3 id="借助Redis的Incr命令获取全局唯⼀ID"><a href="#借助Redis的Incr命令获取全局唯⼀ID" class="headerlink" title="借助Redis的Incr命令获取全局唯⼀ID"></a>借助Redis的Incr命令获取全局唯⼀ID</h3><hr><p>Redis可以保证原子性提供全局id，也是一个推荐的做法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">long</span> id = jedis.incr(<span class="hljs-string">&quot;id&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;从redis中获取的分布式id为：&quot;</span> + id);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != jedis) &#123;<br>            jedis.close();<br>        &#125; <br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU算法</title>
    <link href="/2021/07/23/lru/"/>
    <url>/2021/07/23/lru/</url>
    
    <content type="html"><![CDATA[<p>LRU缓存机制即最少最近使用原则（<code>Least Recently Used</code>的缩写），常见于Redis等内存淘汰机制。也是面试的常考题<br>具体的实现方式是，使用<code>Map + Node</code>双向链表实现，Map可以快速定位Node节点，双向链表方便插入和删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-keyword">private</span> Node head;<br>    <span class="hljs-keyword">private</span> Node tail;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Node&gt; map;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> Node prev;<br>        <span class="hljs-keyword">private</span> Node next;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> key;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;<br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">new</span> Node();<br>        <span class="hljs-keyword">this</span>.tail = <span class="hljs-keyword">new</span> Node();<br>        head.next = tail;<br>        tail.prev = head;<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        Node node = map.get(key);<br>        removeNode(node);<br>        moveHead(node);<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        Node node = map.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 缓存里没有，则需要插入新的节点</span><br>            size++;<br>            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;<br>                <span class="hljs-comment">// 容量已经满了，则需要删除尾节点，并插入新节点</span><br>                Node t = tail.prev;<br>                <span class="hljs-comment">// 删除node</span><br>                map.remove(t.key);<br>                removeNode(t);<br>                size--;<br>            &#125;<br>            node = <span class="hljs-keyword">new</span> Node(key, value);<br>            map.put(key, node);<br>            moveHead(node);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.value = value;<br>            removeNode(node);<br>            moveHead(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveHead</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        <span class="hljs-comment">// 移动节点到头部</span><br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>        node.prev = head;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>面试</tag>
      
      <tag>LRU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一致性Hash算法</title>
    <link href="/2021/07/23/hash/"/>
    <url>/2021/07/23/hash/</url>
    
    <content type="html"><![CDATA[<h3 id="Hash算法使用场景"><a href="#Hash算法使用场景" class="headerlink" title="Hash算法使用场景"></a>Hash算法使用场景</h3><hr><p>Hash算法在分布式领域中有广泛的应用，比如分布式集群架构Redis、Hadoop、ElasticSearch，Mysql分库分表，Nginx负载均衡等</p><ul><li>请求负载均衡(比如nginx的ip_hash策略)</li><li>分布式存储<br>比如根据key做hash取余数，然后请求不同的redis节点</li></ul><h3 id="普通Hash算法"><a href="#普通Hash算法" class="headerlink" title="普通Hash算法"></a>普通Hash算法</h3><hr><p>普通Hash算法存在这样的问题，即如果其中一个节点宕机了，那么hash的结果就不对了，<br>如果后台服务器很多台，客户端也有很多，那么影响是很大的，缩容和扩容都会存在这样的问题。<br><strong>大量用户的请求会被路由到其他的目标服务器处理</strong>，用户在原来服务器中的会话都会丢失。<br>缓存命中率低。</p><h3 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h3><hr><p>一致性Hash算法，保证无论是扩容还是缩容，都只影响一小部分的客户端，并且保证一定的缓存命中率（很多请求还是走的原来的服务节点）。<br>可以增加虚拟节点解决<code>Hash 环数据倾斜的问题</code>，理论上虚拟节点越多分布越均匀</p><h3 id="实现一致性Hash算法"><a href="#实现一致性Hash算法" class="headerlink" title="实现一致性Hash算法"></a>实现一致性Hash算法</h3><hr><p>这里使用<code>TreeMap</code>实现Hash环，hash算法使用默认的<code>hashCode()</code>，如果为了hash均匀，可以采用其他的Hash算法比如<br><code>CRC32_HASH、FNV1_32_HASH、KETAMA_HASH</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsistentHashWithVirtual</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义服务器ip</span><br>        String[] tomcatServers = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;123.111.0.0&quot;</span>, <span class="hljs-string">&quot;123.101.3.1&quot;</span>, <span class="hljs-string">&quot;111.20.35.2&quot;</span>, <span class="hljs-string">&quot;123.98.26.3&quot;</span>&#125;;<br>        <span class="hljs-comment">// hash环用有序Map来模拟</span><br>        <span class="hljs-keyword">final</span> TreeMap&lt;Integer, String&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();<br>        <span class="hljs-comment">// 定义针对每个真实服务器虚拟出来几个节点</span><br>        <span class="hljs-keyword">int</span> virtualCount = <span class="hljs-number">3</span>;<br><br>        <span class="hljs-keyword">for</span> (String tomcatServer : tomcatServers) &#123;<br>            <span class="hljs-comment">// 求出每一个ip的hash值，对应到hash环上，存储hash值与ip的对应关系</span><br>            <span class="hljs-comment">// 直接使用hashCode可能会造成分布不均匀的情况, 可以使用 FNVI_32_HASH 算法</span><br>            <span class="hljs-comment">// 使用 FNVI_32_HASH 算法计算 Hash 值，在服务器增加后，缓存的命中率为 78% 左右</span><br>            <span class="hljs-keyword">int</span> hash = Math.abs(tomcatServer.hashCode());<br>            treeMap.put(hash, tomcatServer);<br><br>            <span class="hljs-comment">// 增加虚拟节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; virtualCount; i++) &#123;<br>                <span class="hljs-comment">// 123.111.0.0#0,123.111.0.0#1,123.111.0.0#2</span><br>                <span class="hljs-keyword">int</span> virtualHash = Math.abs((tomcatServer + <span class="hljs-string">&quot;#&quot;</span> + i).hashCode());<br>                treeMap.put(virtualHash, tomcatServer);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 定义客户端IP</span><br>        String[] clients = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;10.78.12.3&quot;</span>,<span class="hljs-string">&quot;113.25.63.1&quot;</span>,<span class="hljs-string">&quot;126.12.3.8&quot;</span>&#125;;<br><br>        <span class="hljs-keyword">for</span>(String client : clients) &#123;<br>            <span class="hljs-keyword">int</span> hash = Math.abs(client.hashCode());<br>            <span class="hljs-comment">// 向右寻找第一个 key</span><br>            Map.Entry&lt;Integer, String&gt; subEntry = treeMap.ceilingEntry(hash);<br>            <span class="hljs-comment">// 设置成一个环，如果超过尾部，则取第一个点</span><br>            subEntry = subEntry == <span class="hljs-keyword">null</span> ? treeMap.firstEntry() : subEntry;<br>            System.out.println(<span class="hljs-string">&quot;==========&gt;&gt;&gt;&gt;客户端：&quot;</span> + client + <span class="hljs-string">&quot; 被路由到服务器：&quot;</span> + subEntry.getValue());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Nginx配置一致性Hash算法"><a href="#Nginx配置一致性Hash算法" class="headerlink" title="Nginx配置一致性Hash算法"></a>Nginx配置一致性Hash算法</h3><hr><p><code>ngx_http_upstream_consistent_hash</code> 模块是一个负载均衡器，使用一个内部一致性hash算法来选择<br>合适的后端节点。</p><p>该模块可以根据配置参数采取不同的方式将请求均匀映射到后端机器</p><ul><li>consistent_hash $remote_addr:可以根据客户端ip映射</li><li>consistent_hash $request_uri:根据客户端请求的uri映射</li><li>consistent_hash $args:根据客户端携带的参数进行映</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">upstream server &#123;<br>    consistence_hash $$request_uri;<br>    server 127.0.0.1:8080;<br>    server 127.0.0.1:8081;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>一致性Hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typescript高级特性</title>
    <link href="/2021/07/23/ts-union/"/>
    <url>/2021/07/23/ts-union/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Typescript已经是前端工程开发的必备利器和组件库开发的不二之选。<br>在看源码的时候，经常会出现typescript的一些高级特性，比如交叉类型，联合类型和类型保护。适当使用这些特性能帮助我们更好的开发和阅读前端项目。</p><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ObjectConstructor &#123;<br>  assign&lt;T, U&gt;(target: T, <span class="hljs-attr">source</span>: U): T &amp; U;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的是ts的源码，可以看到这里将U拷贝到T类型，返回了T和U的交叉类型</p><p>再举一个简单的例子</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">interface</span> B &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">sayGender</span>: <span class="hljs-function">(<span class="hljs-params">gender: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><br><span class="hljs-keyword">let</span> a: A &amp; B<br><br><span class="hljs-comment">// 都是合法的</span><br>a.age<br>a.sayName<br></code></pre></td></tr></table></figure><p>这里面的a对象继承了接口定义的所有属性</p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型是具有或关系的多个类型组合而成，只要满足其中一个类型即可。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> DateConstructor &#123;<br>  <span class="hljs-keyword">new</span> (value: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">Date</span>): <span class="hljs-built_in">Date</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Date</code>构造函数接受一个number或string或Date类型的参数，对应类型为number | string | Date<br>联合类型A | B要么是A要么是B，因此只有所有源类型的公共成员（“交集”）才能访问。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">interface</span> B &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">sayGender</span>: <span class="hljs-function">(<span class="hljs-params">gender: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><br><span class="hljs-keyword">let</span> a: A | B<br><br><span class="hljs-comment">// 可以访问</span><br>a.name<br><br><span class="hljs-comment">// 不可以访问</span><br>a.age<br>a.sayGender()<br></code></pre></td></tr></table></figure><p>上面的例子中只能访问公共的属性，因为编译器不知道到底是A类型还是B类型，所以只能访问公共的属性。</p><h3 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h3><p>类型保护我的理解是，通过if等条件语句的判断告诉编译器，我知道它的类型了，可以放心调用这种类型的方法，常用的类型保护有<code>typeof</code>类型保护，<code>instanceof</code>类型保护和<strong>自定义类型保护</strong></p><h4 id="typeof类型保护"><a href="#typeof类型保护" class="headerlink" title="typeof类型保护"></a>typeof类型保护</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BuildURL</span>(<span class="hljs-params">param: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">any</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> param.toUpperCase()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的很简单的例子中，由于使用了<code>typeof</code>类型保护，所以在if的分支里可以告诉编译器放心的调用string类型的方法，编译器也会给出自动提示</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BuildURL</span>(<span class="hljs-params">param: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">any</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> param !== <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; param.startsWith(<span class="hljs-string">&quot;xxx&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>结合类型保护编译器会非常的智能，比如上面的例子，编译器知道我们传来的param只有<code>string</code>和<code>number</code>两种类型，由于使用了类型保护，编译器知道param是string类型，所以可以调用startsWith方法。<br>具体的，typeof类型保护能够识别两种形式的typeof：</p><ul><li><code>typeof v === &quot;typename&quot;</code></li><li><code>typeof v !== &quot;typename&quot;</code></li></ul><p>typename只能是number、string、boolean或symbol，因为其余的typeof检测结果不那么可靠，比如</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">any</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>  <span class="hljs-comment">// any类型，typeof类型保护不适用</span><br>  x;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>  <span class="hljs-comment">// any类型，typeof类型保护不适用</span><br>  x;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以有时候我们需要使用自定义方式实现保护类型</p><h3 id="instanceof类型保护"><a href="#instanceof类型保护" class="headerlink" title="instanceof类型保护"></a>instanceof类型保护</h3><p>instanceof类型保护和typeof类型用法相似，它主要是用来判断是否是一个类的对象或者继承对象的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">Date</span> | <span class="hljs-built_in">RegExp</span>;<br><span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) &#123;<br>  <span class="hljs-comment">// 正确 instanceof类型保护，自动对应到RegExp实例类型</span><br>  x.test(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 正确 自动对应到Date实例类型</span><br>  x.getTime();<br>&#125;<br><br><span class="hljs-keyword">interface</span> DateOrRegExp &#123;<br>    <span class="hljs-comment">// 这里表示构造器无参，Date类型的类</span><br>    <span class="hljs-keyword">new</span>(): <span class="hljs-built_in">Date</span>;<br>    <span class="hljs-keyword">new</span>(value?: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">RegExp</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> A: DateOrRegExp;<br><span class="hljs-keyword">let</span> y;<br><span class="hljs-keyword">if</span> (y <span class="hljs-keyword">instanceof</span> A) &#123;<br>    <span class="hljs-comment">// y从any到RegExp | Date</span><br>    y;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义类型保护"><a href="#自定义类型保护" class="headerlink" title="自定义类型保护"></a>自定义类型保护</h3><p>typeof与instanceof类型保护能够满足一般场景，对于一些更加特殊的，可以通过自定义类型保护来对应类型,比如我们自己定义一个请求参数的接口类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> RequestParams &#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>,<br>  onSuccess?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>,<br>  onFailure?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidRequestParams</span>(<span class="hljs-params">request: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">request</span> <span class="hljs-title">is</span> <span class="hljs-title">RequestParams</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> request &amp;&amp; request.url<br>&#125;<br><br><span class="hljs-keyword">let</span> request<br><br><span class="hljs-comment">// 检测客户端发送过来的参数</span><br><span class="hljs-keyword">if</span> (isValidRequestParams(request))&#123;<br>  request.url<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面通过判断，我们需要手动告诉编译器通过isValidRequestParams的判断则request就是RequestParams类型的参数，编译器如何知道这一点呢，我们在这里通过类型谓词<code>parameterName is Type</code>告诉了编译器，isValidRequestParams返回了true则request就是RequestParams类型。<br>其它用法和上面所列举的一致</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> isNumber: <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) =&gt;</span> value is <span class="hljs-built_in">number</span>;<br><br><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">if</span> (isNumber(x)) &#123;<br>  <span class="hljs-comment">// 缩窄到number</span><br>  x.toFixed(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 通过类型保护，编译器知道不是number就是string</span><br>  x.toUpperCase();<br>&#125;<br></code></pre></td></tr></table></figure><p>结合类型保护，编译器会更加的智能，也能极大地降低bug出现的风险。</p><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><ul><li><p>new()类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">c: &#123; <span class="hljs-keyword">new</span>(): T &#125;</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> c()<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello test class&quot;</span>)<br>  &#125;<br>&#125;<br><br>create(Test)<br></code></pre></td></tr></table></figure><p>在typescript中，要实现工厂模式是很容易的，我们只需要先声明一个构造函数的类型参数，它构造出来的是T类型new():T，然后在函数体里面返回c这个类构造出来的对象即可。</p></li><li><p>空类型安全</p></li></ul><p>针对空类型的潜在问题，TypeScript提供了–strictNullChecks选项，开启之后会严格检查空类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">string</span>;<br><span class="hljs-comment">// 错误 Type &#x27;null&#x27; is not assignable to type &#x27;string&#x27;.</span><br>x = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 错误 Type &#x27;undefined&#x27; is not assignable to type &#x27;string&#x27;.</span><br>x = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typescript</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android仿今日头条图片滑动退出效果</title>
    <link href="/2021/07/23/coupon-photo/"/>
    <url>/2021/07/23/coupon-photo/</url>
    
    <content type="html"><![CDATA[<h3 id="Android仿今日头条图片滑动退出效果-Kotlin版"><a href="#Android仿今日头条图片滑动退出效果-Kotlin版" class="headerlink" title="Android仿今日头条图片滑动退出效果-Kotlin版"></a>Android仿今日头条图片滑动退出效果-Kotlin版</h3><p>主要功能:</p><ol><li>在下滑时，随着手指的移动，图片区域跟随移动，并且activity的背景和页码逐渐变的透明</li><li>滑动距离不超过设定的临界值时，会有回弹效果。</li><li>滑动超过设置的临界值时，放开手指，页面滑动退出消失</li><li>图片可以正常放大缩小，页面不跟随手指上下滑动</li><li>使用了共享元素的页面切换效果</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SlideCloseLayout</span></span>(context: Context, attrs: AttributeSet? = <span class="hljs-literal">null</span>) : FrameLayout(context, attrs) &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> previousX: <span class="hljs-built_in">Float</span> = <span class="hljs-number">0f</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> previousY: <span class="hljs-built_in">Float</span> = <span class="hljs-number">0f</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> scrollListener: LayoutScrollListener? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">init</span> &#123;<br>        background?.alpha = <span class="hljs-number">255</span><br>    &#125;<br><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(ev: <span class="hljs-type">MotionEvent</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        ev?.pointerCount?.let &#123;<br>            <span class="hljs-keyword">if</span> (it &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">val</span> y: <span class="hljs-built_in">Float</span> = ev.rawY<br>            <span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Float</span> = ev.rawX<br>            <span class="hljs-keyword">when</span> (ev.action) &#123;<br>                MotionEvent.ACTION_DOWN -&gt; &#123;<br>                    previousX = x<br>                    previousY = y<br>                &#125;<br>                MotionEvent.ACTION_MOVE -&gt; &#123;<br>                    <span class="hljs-keyword">val</span> diffY = y - previousY<br>                    <span class="hljs-keyword">val</span> diffX = x - previousX<br>                    <span class="hljs-keyword">if</span> (diffY &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>                    <span class="hljs-keyword">if</span> (Math.abs(diffX) + <span class="hljs-number">50</span> &lt; Math.abs(diffY)) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(ev: <span class="hljs-type">MotionEvent</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        ev?.let &#123;<br>            <span class="hljs-keyword">val</span> y = ev.rawY<br>            <span class="hljs-keyword">val</span> x = ev.rawX<br>            <span class="hljs-keyword">when</span> (ev.action) &#123;<br>                MotionEvent.ACTION_DOWN -&gt; &#123;<br>                    previousX = x<br>                    previousY = y<br>                &#125;<br>                MotionEvent.ACTION_MOVE -&gt; &#123;<br>                    <span class="hljs-keyword">val</span> diffY = Math.max(y - previousY, <span class="hljs-number">0f</span>)<br>                    translationY = diffY<br>                    <span class="hljs-keyword">val</span> alpha = diffY / height<br>                    <span class="hljs-keyword">this</span>.alpha = <span class="hljs-number">1f</span> - alpha<br>                &#125;<br>                MotionEvent.ACTION_UP -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (Math.abs(translationY) &gt; (height / <span class="hljs-number">4</span>)) &#123;<br>                        layoutExitAnim()<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        layoutRecoverAnim()<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> -&gt; &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(ev)<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(ev)<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setLayoutScrollListener</span><span class="hljs-params">(listener: <span class="hljs-type">LayoutScrollListener</span>)</span></span> &#123;<br>        scrollListener = listener<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">layoutRecoverAnim</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> recoverAnim = ObjectAnimator.ofFloat(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;translationY&quot;</span>, <span class="hljs-keyword">this</span>.translationY, <span class="hljs-number">0f</span>)<br>        recoverAnim.duration = <span class="hljs-number">100</span><br>        recoverAnim.start()<br>        <span class="hljs-keyword">this</span>.alpha = <span class="hljs-number">1f</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">layoutExitAnim</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> exitAnim: ObjectAnimator = ObjectAnimator.ofFloat(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;translationY&quot;</span>, translationY, height.toFloat())<br>        exitAnim.addListener(<span class="hljs-keyword">object</span> : AnimatorListenerAdapter() &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAnimationEnd</span><span class="hljs-params">(animation: <span class="hljs-type">Animator</span>?)</span></span> &#123;<br>                <span class="hljs-keyword">this</span><span class="hljs-symbol">@SlideCloseLayout</span>.alpha = <span class="hljs-number">0f</span><br>                scrollListener?.onLayoutClosed()<br>            &#125;<br>        &#125;)<br>        exitAnim.addUpdateListener &#123;<br>            <span class="hljs-keyword">this</span>.alpha = <span class="hljs-number">1</span> - translationY / height<br>        &#125;<br>        exitAnim.duration = <span class="hljs-number">200</span><br>        exitAnim.start()<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LayoutScrollListener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLayoutClosed</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里自定义了一个Layout，为了能够监听手指滑动的事件</p><p>布局文件只要在这个自定义下嵌套即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br> <br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">jp.hotpepper.android.beauty.hair.application.widget.SlideCloseLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/slide_close_layout&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@color/beauty_text_black&quot;</span>&gt;</span><br> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">android.support.v4.view.ViewPager</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/coupon_photo_view_pager&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center&quot;</span> /&gt;</span><br> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/text_view_current_page&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;bottom|center&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginBottom</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/beauty_text_white&quot;</span> /&gt;</span><br> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/image_view_button_close&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;top|left&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginLeft</span>=<span class="hljs-string">&quot;15dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;25dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/btn_close_circle&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:foreground</span>=<span class="hljs-string">&quot;?android:attr/selectableItemBackground&quot;</span> /&gt;</span><br> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">jp.hotpepper.android.beauty.hair.application.widget.SlideCloseLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这里我们因为使用了自动绑定，所以最外层需要绑定一个Layout</p><p>然后是我们的图片画廊展示类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CouponPhotoViewPagerActivity</span> : <span class="hljs-type">BaseActivity</span></span>() &#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> photoUrls: ArrayList&lt;String&gt; <span class="hljs-keyword">by</span> extra()<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> binding <span class="hljs-keyword">by</span> binding&lt;ActivityCouponPhotoViewPagerBinding&gt;(R.layout.activity_coupon_photo_view_pager)<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewPager: ViewPager <span class="hljs-keyword">by</span> lazy &#123;<br>        binding.couponPhotoViewPager<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> closeImageView: ImageView <span class="hljs-keyword">by</span> lazy &#123;<br>        binding.imageViewButtonClose<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> showCurrentPage: TextView <span class="hljs-keyword">by</span> lazy &#123;<br>        binding.textViewCurrentPage<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> slideCloseLayout: SlideCloseLayout <span class="hljs-keyword">by</span> lazy &#123;<br>        binding.slideCloseLayout<br>    &#125;<br> <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        initComponent()<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initComponent</span><span class="hljs-params">()</span></span> &#123;<br>        activityComponent.inject(<span class="hljs-keyword">this</span>)<br>        viewPager.adapter = CouponPhotoViewPagerAdapter(photoUrls)<br>        viewPager.setTransitionNameCompat(SHARED_ELEMENT_NAME)<br>        showCurrentPage.text = getString(R.string.coupon_photo_view_current_page, <span class="hljs-number">1</span>, photoUrls.size)<br>        initEventListener()<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initEventListener</span><span class="hljs-params">()</span></span> &#123;<br>        closeImageView.setOnClickListener &#123;<br>            finishAfterTransitionCompat()<br>        &#125;<br>        viewPager.addOnPageChangeListener(<span class="hljs-keyword">object</span> : ViewPager.SimpleOnPageChangeListener() &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onPageSelected</span><span class="hljs-params">(p0: <span class="hljs-type">Int</span>)</span></span> &#123;<br>                showCurrentPage.text = getString(R.string.coupon_photo_view_current_page, p0 + <span class="hljs-number">1</span>, photoUrls.size)<br>            &#125;<br>        &#125;)<br><br>        slideCloseLayout.setLayoutScrollListener(<span class="hljs-keyword">object</span> : LayoutScrollListener &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLayoutClosed</span><span class="hljs-params">()</span></span> &#123;<br>                finish()<br>                overridePendingTransition(R.anim.fade_in, R.anim.fade_out)<br>            &#125;<br>        &#125;)<br>    &#125;<br>    <br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> SHARED_ELEMENT_NAME = <span class="hljs-string">&quot;sharedView&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intent</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, photoUrls: <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>: Intent =<br>                Intent(context, CouponPhotoViewPagerActivity::<span class="hljs-keyword">class</span>.java)<br>                        .put(CouponPhotoViewPagerActivity::photoUrls, ArrayList(photoUrls))<br><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transitionOptions</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>, sharedElement: <span class="hljs-type">View</span>)</span></span> = ActivityOptionsCompat.makeSceneTransitionAnimation(activity, sharedElement, SHARED_ELEMENT_NAME).toBundle()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>给这个activity定一个主题，不然在下滑的时候是不能透明的，也看不到之前的activity</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;SlideCloseTheme&quot;</span>&gt;</span><span class="xml"></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;windowNoTitle&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowFullscreen&quot;</span>&gt;</span>?android:windowNoTitle<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowIsTranslucent&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowBackground&quot;</span>&gt;</span>@android:color/transparent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowNoTitle&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个主题表示activity是全屏显示并且可以透明化的。</p><p>然后，在manifest.xml中应用这个主题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.application.activity.CouponPhotoViewPagerActivity&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:configChanges</span>=<span class="hljs-string">&quot;orientation&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:screenOrientation</span>=<span class="hljs-string">&quot;portrait&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/SlideCloseTheme&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>实现效果还是很不错的。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx的那些事儿</title>
    <link href="/2021/07/22/nginx/"/>
    <url>/2021/07/22/nginx/</url>
    
    <content type="html"><![CDATA[<p>Nginx是一个高并发，低内存占用的web服务器，单机可以达到5wQPS以上，并且内存占用非常低</p><h3 id="nginx常用命令"><a href="#nginx常用命令" class="headerlink" title="nginx常用命令"></a>nginx常用命令</h3><ul><li>nginx主要命令<ul><li><code>./nginx</code> 启动nginx</li><li><code>./nginx -s stop</code> 终止nginx(当然也可以找到nginx进程号，然后使用kill -9 杀掉nginx进程)</li><li><code>./nginx -s reload</code> (重新加载nginx.conf配置文件)</li></ul></li></ul><h3 id="nginx核心配置"><a href="#nginx核心配置" class="headerlink" title="nginx核心配置"></a>nginx核心配置</h3><p>nginx的配置分为<em>全局块</em>、<em>events块</em>、<em>http块</em></p><h4 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h4><p>从配置文件开始到events块之间的内容，此处的配置影响nginx服务器整体的运行，比如worker进 程的数量、错误日志的位置等</p><h4 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h4><p>events块主要影响nginx服务器与用户的网络连接，比如worker_connections为1024，表示每个<br>worker process 支持的最大连接数为1024</p><h4 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h4><p>http块是配置最频繁的部分，如虚拟主机的配置，监听端口的配置，请求转发、反向代理、负载均衡等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs text"><br>#user  nobody;<br># worker进程数量，即工作进程，通常设置=cpu数量<br>worker_processes  1;<br># 全局错误日志和pid文件位置<br>#error_log  logs/error.log;<br>#error_log  logs/error.log  notice;<br>#error_log  logs/error.log  info;<br><br>#pid        logs/nginx.pid;<br><br># events模块，影响nginx服务器和用户的网络连接<br>events &#123;<br>    # 单个worker连接的最大并发连接数<br>    # 总处理量 = worker_processes * worker_connections<br>    worker_connections  1024;<br>&#125;<br><br><br>http &#123;<br>    include       mime.types;<br>    default_type  application/octet-stream;<br><br>    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;<br>    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;<br>    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;<br><br>    #access_log  logs/access.log  main;<br><br>    sendfile        on;<br>    #tcp_nopush     on;<br><br>    #keepalive_timeout  0;<br>    # 连接超时时间<br>    keepalive_timeout  65;<br><br>    # 压缩<br>    #gzip  on;<br><br>    server &#123;<br>        # 监听的端口<br>        listen       80;<br>        # 虚拟主机 www.xxx.com<br>        server_name  localhost;<br><br>        #charset koi8-r;<br><br>        #access_log  logs/host.access.log  main;<br><br>        # 默认请求<br>        # tomcat context<br>        location / &#123;<br>            root   html; # 网站的根目录<br>            index  index.html index.htm;<br>        &#125;<br><br>        #error_page  404              /404.html;<br><br>        # redirect server error pages to the static page /50x.html<br>        #<br>        error_page   500 502 503 504  /50x.html;<br>        location = /50x.html &#123;<br>            root   html;<br>        &#125;<br><br>        # proxy the PHP scripts to Apache listening on 127.0.0.1:80<br>        #<br>        #location ~ \.php$ &#123;<br>        #    proxy_pass   http://127.0.0.1;<br>        #&#125;<br><br>        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000<br>        #<br>        #location ~ \.php$ &#123;<br>        #    root           html;<br>        #    fastcgi_pass   127.0.0.1:9000;<br>        #    fastcgi_index  index.php;<br>        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;<br>        #    include        fastcgi_params;<br>        #&#125;<br><br>        # deny access to .htaccess files, if Apache&#x27;s document root<br>        # concurs with nginx&#x27;s one<br>        #<br>        #location ~ /\.ht &#123;<br>        #    deny  all;<br>        #&#125;<br>    &#125;<br><br><br>    # another virtual host using mix of IP-, name-, and port-based configuration<br>    #<br>    #server &#123;<br>    #    listen       8000;<br>    #    listen       somename:8080;<br>    #    server_name  somename  alias  another.alias;<br><br>    #    location / &#123;<br>    #        root   html;<br>    #        index  index.html index.htm;<br>    #    &#125;<br>    #&#125;<br><br><br>    # HTTPS server<br>    #<br>    #server &#123;<br>    #    listen       443 ssl;<br>    #    server_name  localhost;<br><br>    #    ssl_certificate      cert.pem;<br>    #    ssl_certificate_key  cert.key;<br><br>    #    ssl_session_cache    shared:SSL:1m;<br>    #    ssl_session_timeout  5m;<br><br>    #    ssl_ciphers  HIGH:!aNULL:!MD5;<br>    #    ssl_prefer_server_ciphers  on;<br><br>    #    location / &#123;<br>    #        root   html;<br>    #        index  index.html index.htm;<br>    #    &#125;<br>    #&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>比如 xxx.com/abc -&gt; tomcat 8080, xxx.com/def -&gt; tomcat 8081</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">server &#123;<br>        listen       80;<br>        server_name  localhost;<br>        #charset koi8-r;<br>        #access_log  logs/host.access.log  main;<br> <br>        location /abc &#123;<br>            proxy_pass   http://127.0.0.1:8080;<br>        &#125;<br>        <br>        location /def &#123;<br>            http://127.0.0.1:8081;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>相同请求会分发到不同的服务器上，降低单个节点的请求压力</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text"># 配置集群的信息, 默认是轮询策略, weight值越大越有可能被分配到<br>upstream xxxServer &#123;<br>    server 127.0.0.1:8080 max_fails=3 fail_timeout=3s weight=2;<br>    server 127.0.0.1:8082;<br>&#125;<br>server &#123;<br>        listen       80;<br>        server_name  localhost;<br>        #charset koi8-r;<br>        #access_log  logs/host.access.log  main;<br> <br>        location /abc &#123;<br>            proxy_pass   http://xxxServer;<br>        &#125;<br>        <br>        location /def &#123;<br>            proxy_pass http://127.0.0.1:8081;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h4><ul><li>轮询<br>默认策略，每个请求按时间顺序逐一分配到不同的服务器，如果某一个服务器下线，能自动剔除</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">upstream xxxServer&#123;<br>    server 111.229.248.243:8080; <br>    server 111.229.248.243:8082;<br>&#125;<br>location /abc &#123;<br>    proxy_pass http://xxxServer;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>weight<br>weight代表权重，默认每一个负载的服务器都为1，权重越高那么被分配的请求越多(用于服务器性能不均衡的场景)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">upstream xxxServer&#123;<br>    server 111.229.248.243:8080 weight=1; <br>    server 111.229.248.243:8082 weight=2;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ip_hash<br>每个请求按照ip的hash结果分配，每一个客户端的请求会固定分配到同一个目标服务器处理，可以解决session问题</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">upstream xxxServer&#123; <br>    ip_hash;<br>    server 111.229.248.243:8080;<br>    server 111.229.248.243:8082; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>Nginx在静态资源请求上性能较好，业务处理交给Tomcat，实现动静分离。<br>Nginx实现静态资源配置也很容易，只需要将静态资源文件放到<em>Nginx服务器</em>上，在配置文件上修改即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">location /static/ &#123;<br>    # nginx服务器目录加载，需要自己创建<br>    root staticDir;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Nginx底层进程机制"><a href="#Nginx底层进程机制" class="headerlink" title="Nginx底层进程机制"></a>Nginx底层进程机制</h4><p>Nginx启动后，以daemon多进程方式在后台运行，包括一个Master进程和多个Worker进程，Master<br>进程负责管理和监控Worker进程，Worker进程负责处理具体的请求。</p><ul><li>master进程 主要是管理worker进程，比如:<ul><li>接收外界信号向各worker进程发送信号(./nginx -s reload)</li><li>监控worker进程的运行状态，当worker进程异常退出后Master进程会自动重新启动新的worker进程</li></ul></li><li>worker进程worker进程具体处理网络请求。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。<br>nginx使用互斥锁来保证只有一个worker进程能够处理请求</li></ul><p>多进程机制的好处：</p><ul><li>一个进程挂了，其他进程可以照样提供服务</li><li>为热部署提供支撑，主要就是reload配置文件的时候，不会影响到旧请求的处理</li></ul><h4 id="nginx信号处理"><a href="#nginx信号处理" class="headerlink" title="nginx信号处理"></a>nginx信号处理</h4><p>以 <code>./nginx -s reload</code> 来说明nginx信号处理这部分 </p><ol><li>master进程对配置文件进行语法检查 </li><li>尝试配置(比如修改了监听端口，那就尝试分配新的监听端口) </li><li>尝试成功则使用新的配置，<strong>新建worker进程</strong> </li><li>新建成功，给旧的worker进程发送关闭消息 </li><li>旧的worker进程收到信号会<strong>继续服务</strong>，直到把当前进程接收到的请求处理完毕后关闭 所以reload之后worker进程pid是发生了变化的</li></ol>]]></content>
    
    
    <categories>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2021/07/22/quick-sort/"/>
    <url>/2021/07/22/quick-sort/</url>
    
    <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>经典的快速排序使用了分治的思想，平均复杂度为O(nlgn)，最坏的情况会退化为O(n^2)</p><p>快排的核心思想就是，找到一个点，先把比它小的排在左边，比它大的排在右边，然后一直递归排下去</p><p><a href="https://leetcode-cn.com/problems/sort-an-array/">Leetcode 912</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortArray(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        partition(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> pivot = nums[left]; <span class="hljs-comment">// 比较值</span><br>        <span class="hljs-keyword">int</span> j = left; <span class="hljs-comment">// 分界点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left + <span class="hljs-number">1</span>; i &lt;= right; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; pivot) &#123;<br>                j++;<br>                swap(nums, i, j);<br>            &#125;<br>        &#125;<br>        swap(nums, left, j);<br>        partition(nums, j + <span class="hljs-number">1</span>, right);<br>        partition(nums, left, j - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> tmp = nums[j];<br>        nums[j] = nums[i];<br>        nums[i] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="加上随机因子的快速排序"><a href="#加上随机因子的快速排序" class="headerlink" title="加上随机因子的快速排序"></a>加上随机因子的快速排序</h3><p>为了避免出现最坏的情况O(n^2)，我们可以引入随机因子，即在每一次分治的步骤中都加上随机的<strong>pivot</strong>，并交换位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 加上随机因子，ran表示的是随机的位置</span><br>        <span class="hljs-keyword">int</span> ran = random.nextInt(right - left + <span class="hljs-number">1</span>) + left;<br>        swap(nums, left, ran);<br>        <span class="hljs-keyword">int</span> pivot = nums[left]; <span class="hljs-comment">// 比较值</span><br>        <span class="hljs-keyword">int</span> j = left; <span class="hljs-comment">// 分界点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left + <span class="hljs-number">1</span>; i &lt;= right; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; pivot) &#123;<br>                j++;<br>                swap(nums, i, j);<br>            &#125;<br>        &#125;<br>        swap(nums, left, j);<br>        partition(nums, j + <span class="hljs-number">1</span>, right);<br>        partition(nums, left, j - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><p>和快速排序类似，快速选择不需要全部排完，只需要对K个元素排好序，然后取K个元素即可</p><p><a href="https://leetcode-cn.com/problems/smallest-k-lcci/">Leetcode 最小的K个数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] smallestK(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;<br>        partition(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k);<br>        <span class="hljs-keyword">return</span> Arrays.copyOfRange(arr, <span class="hljs-number">0</span>, k);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> j = l;<br>        <span class="hljs-keyword">int</span> pivot = arr[l];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = j + <span class="hljs-number">1</span>; i &lt;= r; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; pivot) &#123;<br>                j++;<br>                swap(arr, i, j);<br>            &#125;<br>        &#125;<br>        swap(arr, l, j);<br>        <span class="hljs-keyword">if</span> (j == k) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &lt; k) &#123;<br>            partition(arr, j + <span class="hljs-number">1</span>, r, k);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            partition(arr, l, j - <span class="hljs-number">1</span>, k);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> tmp = arr[j];<br>        arr[j] = arr[i];<br>        arr[i] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/">Leetcode 最接近原点的 K 个点</a><br>这道题把比较的值替换为到原点的距离，其他的解题思路是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] kClosest(<span class="hljs-keyword">int</span>[][] points, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (points.length &lt;= k) &#123;<br>            <span class="hljs-keyword">return</span> points;<br>        &#125;<br>        quickSelect(points, <span class="hljs-number">0</span>, points.length - <span class="hljs-number">1</span>, k);<br>        <span class="hljs-keyword">return</span> Arrays.copyOfRange(points, <span class="hljs-number">0</span>, k);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pivot = distance(points[start]);<br>        <span class="hljs-keyword">int</span> j = start;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start + <span class="hljs-number">1</span>; i &lt;= end; i++) &#123;<br>            <span class="hljs-keyword">if</span> (distance(points[i]) &lt; pivot) &#123;<br>                j++;<br>                swap(points, i, j);<br>            &#125;<br>        &#125;<br>        swap(points, start, j);<br>        <span class="hljs-keyword">if</span> (j == k) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &lt; k) &#123;<br>            quickSelect(points, j + <span class="hljs-number">1</span>, end, k);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            quickSelect(points, start, j - <span class="hljs-number">1</span>, k);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] point)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> point[<span class="hljs-number">0</span>] * point[<span class="hljs-number">0</span>] + point[<span class="hljs-number">1</span>] * point[<span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] tmp = points[i];<br>        points[i] = points[j];<br>        points[j] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>面试</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
