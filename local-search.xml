<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM详解</title>
    <link href="/2022/02/18/jvm/"/>
    <url>/2022/02/18/jvm/</url>
    
    <content type="html"><![CDATA[<h3 id="JVM加载过程"><a href="#JVM加载过程" class="headerlink" title="JVM加载过程"></a>JVM加载过程</h3><p>JVM类加载首先会编译java代码为class文件，然后Java虚拟机会加载class文件，类加载具体会有以下的步骤：</p><ol><li>加载 文件到内存的过程。通过类的完全限定名查找此类的字节码文件，并利用字节码文件创建一个 Class 对象。</li><li>验证 对类文件内容验证。目的在于确保 Class 文件符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种：文件格式验证，元数据验证，字节码验证，符号引用验证。</li><li>准备 进行内存分配。为类变量也就是类中由 static 修饰的变量分配内存，并且设置初始值。这里要注意，初始值是 0 或者null，而不是代码中设置的具体值，代码中设置的值是在初始化阶段完成的。另外这里也不包含用 <code>final</code> 修饰的静态变量，因为 <code>final</code> 在编译的时候就会分配。</li><li>解析 主要是解析字段、接口、方法。主要是将常量池中的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针、相对偏移量等。</li><li>初始化 主要完成静态块执行与静态变量的赋值。这是类加载最后阶段，若被加载类的父类没有初始化，则先对父类进行初始化。</li></ol><p>加载流程如下图:</p><p><img src="jvm-loadclass.png" alt="类加载流程图"></p><h3 id="双亲委派模型【parents-delegate】"><a href="#双亲委派模型【parents-delegate】" class="headerlink" title="双亲委派模型【parents delegate】"></a>双亲委派模型【parents delegate】</h3><p>双亲委派其实真正的翻译应该是父类委托</p><p>双亲委派模型其实就是JVM在加载的过程，默认会优先委托给父加载器加载，JVM的内部内置了3个重要的 <code>ClassLoader</code></p><ol><li>BootstrapClassLoader(启动类加载器)：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code> 目录下的jar包和类或者或被 <code>-Xbootclasspath</code> 参数指定的路径中的所有类。</li><li>ExtensionClassLoader(扩展类加载器)：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。(jdk9之后使用PlatformClassLoader替代了ExtensionClassLoader)</li><li>AppClassLoader(应用程序类加载器): 面向用户的加载器，负责加载当前应用 <strong>classpath</strong> 下的所有jar包和类。</li></ol><p>双亲委派模型在代码层的实现其实就是利用了递归实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        <span class="hljs-comment">// 判断是否被加载过</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 父加载器不为空，调用父加载器loadClass()方法处理，层层向上传递，走这个方法做递归</span><br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 递归终止条件，使用Bootstrap加载</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br>            <span class="hljs-comment">// 父类加载器加载不到，则由自己加载</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 尝试自己加载</span><br>                c = findClass(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面对于 loadClass(String name, boolean resolve)方法的解析来看，可以得出以下2个结论：</p><p>1、如果不想打破双亲委派模型，那么只需要重写findClass方法即可</p><p>2、如果想打破双亲委派模型，那么就重写整个loadClass方法</p><p>我们在进行非classpath路径下的类加载，可以重写 loadClass 方法，指定路径加载, 在调用<code>Class.forName</code>方法，可以指定自己的类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>    <span class="hljs-keyword">if</span> (name.startsWith(<span class="hljs-string">&quot;org.xzw.classpath&quot;</span>)) &#123;<br>        c = findClass(name); <span class="hljs-comment">// 自定义</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        c = <span class="hljs-keyword">this</span>.getParent().loadClass(name);<br>    &#125;<br>    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>    PerfCounter.getFindClasses().increment();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JVM常用参数"><a href="#JVM常用参数" class="headerlink" title="JVM常用参数"></a>JVM常用参数</h3><ul><li>-Xms: Java堆内存初始大小</li><li>-Xmx: Java堆内存最大大小</li><li>-Xmn: 新生代大小，减去新生代就是老年代大小</li><li>-XX:PermSize, -XX:MetaspaceSize: 永久代大小</li><li>-XX:MaxPermSize, -XX:MaxMetaspaceSize: 最大永久代大小</li><li>-Xss: 栈内存大小，一般512k或者1M</li><li>-XX:SurvivorRatio: Eden和Survivor的大小比，默认是8</li><li>-XX:MaxTenuringThreshold: 分代回收年龄</li><li>-XX:TargetSurvivorRatio: 动态年龄判断阈值，默认50%</li><li>-XX:CMSInitiatingOccupancyFaction 老年代占用多少比例触发CMS垃圾回收</li><li>-XX:InitiatingHeapOccupancyPercent: G1老年代占据了Region多少比例，会混合回收，默认45%</li><li>-XX:UseCMSCompactAtFullCollection CMS在Full GC之后，stop the world进行碎片整理，默认是打开的</li><li>-XX:CMSFullGCsBeforeCompaction 执行多少Full GC再进行碎片整理，默认0，每次都会执行</li><li>XX:+CMSParallelInitialMarkEnabled：这个参数会在CMS垃圾回收器的“初始标记”阶段开启多线程并发执行</li><li>-XX:+CMSScavengeBeforeRemark：这个参数会在CMS的重新标记阶段之前，先尽量执行一次Young GC，这样可以少扫描一些对象</li><li>-XX:+HeapDumpOnOutOfMemoryError OOM错误的时候导出文件</li><li>-XX:HandlePromotionFailure 内存担保，每次老年代可用空间大于新生代对象或者大于每次晋升老年代的平均对象，就可以Minor GC，1.7以后是默认行为，可以不设置这个参数</li><li>-XX:UseG1GC 指定使用G1垃圾收集器</li><li>-XX:G1MaxNewSizePercent G1新生代最大占比</li><li>-XX:MaxGCPauseMills G1期望停顿时间</li><li>-XX:+HeapDumpOnOutOfMemoryError</li><li>-XX:+HeapDumpPath=/usr/local/app/oom</li><li>-XX:+DisableExplicitGC 禁止手动GC</li></ul><p>JVM垃圾收集器选择思路：</p><ol><li>中小内存，可以使用ParNew+CMS组合</li><li>大内存，延迟小，使用G1或者ZGC垃圾收集器</li></ol><p>进入老年代的情况：</p><ol><li>YGC时，Survivor区不足以存放存活的对象，对象会直接进入到老年代。</li><li>经过多次YGC后，如果存活对象的年龄达到了设定阈值，则会晋升到老年代中。</li><li>动态年龄判定规则，Survivor区中相同年龄的对象，如果其大小之和占到了 Survivor 区一半以上的空间，那么大于此年龄的对象会直接进入老年代，而不需要达到默认的分代年龄。</li><li>大对象：由 <code>-XX:PretenureSizeThreshold</code> 启动参数控制，若对象大于此值，就会绕过新生代, 直接在老年代中分配。</li></ol><h3 id="OOM常见问题分析"><a href="#OOM常见问题分析" class="headerlink" title="OOM常见问题分析"></a>OOM常见问题分析</h3><ol><li>高并发场景 <br/><br>高并发QPS一般都在几千几万，这时候会频繁的Yong GC，导致每次会有不少对象进入老年代，触发Full GC，现象就是每几分钟甚至几秒就会卡一次。<br>这时候就增大新生代内存和增大survivor内存空间，这样可以避免每次回收因为存活对象太多，survivor放不下而频繁进入老年代，此外需要注意，最好每次Full GC就整理一次内存碎片，<br>避免因为连续空间不够导致的频繁Full GC。<br>如果不合理的使用了本地缓存一直存数据，不去进行淘汰，也会导致大量的类在老年代，导致频繁Full GC</li><li>大量反射场景 <br/><br>大量反射场景，JVM会生成很多的临时类。比如不合理使用动态代理，就会频繁加载代理类带来Metaspace满而Full GC，进一步导致OOM的问题</li></ol><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><ol><li>G1默认的是复制算法，效率高，没有内存碎片，把一个Region的存活对象复制到另一个Region</li><li>G1会分为很多相同的Region（默认2048），只在逻辑上分为新生代和老年代，并且能设置为期望停顿时间，G1自动选择最少回收时间和最多回收对象</li><li>刚开始默认G1新生代为5%，大概100个region，JVM会给新生代增加region，默认最多不超过60%</li><li>G1还是有Eden和Survivor的概念，但是会根据XX:MaxGCPauseMills回收一部分，晋升老年代规则基本不变</li><li>Region角色会动态变化，没有固定的新生代Region，老年代Region</li></ol><h3 id="常用JVM参数模版"><a href="#常用JVM参数模版" class="headerlink" title="常用JVM参数模版"></a>常用JVM参数模版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">-Xms4096M -Xmx4096M -Xmn3072M -Xss1M<br>-XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M<br>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC<br>-XX:CMSInitiatingOccupancyFraction=92<br>-XX:+UseCMSCompactAtFullCollection<br>-XX:CMSFullGCsBeforeCompaction=0<br>XX:+CMSParallelInitialMarkEnabled<br>-XX:+CMSScavengeBeforeRemark<br>-XX:+PrintGCDetails<br>-Xloggc:gc.log<br>-XX:+HeapDumpOnOutOfMemoryError<br>-XX:+HeapDumpPath=/usr/local/app/oom<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>内存问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal原理和使用的问题</title>
    <link href="/2022/01/07/threadlocal/"/>
    <url>/2022/01/07/threadlocal/</url>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal源码"><a href="#ThreadLocal源码" class="headerlink" title="ThreadLocal源码"></a>ThreadLocal源码</h2><p>ThreadLocal可以实现每个线程的隔离，自定义线程级别的变量，使用如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyyMMdd HHmm&quot;</span>));<br></code></pre></td></tr></table></figure><p>可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><p>ThreadLocal使用了ThreadLocalMap去存取值，而每个Thread类都有自己的ThreadLocalMap，ThreadLocalMap底层使用的是<br>Entry[] table，用来保存每个ThreadLocal对应的value。</p><p>具体的源码分析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义在ThreadLocal里面，被每个Thread所引用：ThreadLocal.ThreadLocalMap threadLocals</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The entries in this hash map extend WeakReference, using</span><br><span class="hljs-comment">     * its main ref field as the key (which is always a</span><br><span class="hljs-comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><br><span class="hljs-comment">     * == null) mean that the key is no longer referenced, so the</span><br><span class="hljs-comment">     * entry can be expunged from table.  Such entries are referred to</span><br><span class="hljs-comment">     * as &quot;stale entries&quot; in the code that follows.</span><br><span class="hljs-comment">     * Entry的Key为弱引用，而value是强引用，会导致内存泄漏</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;<br>        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>        Object value;<br><br>        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>            <span class="hljs-keyword">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 每个ThreadLocal作为一个key，求hash之后取余，设置value</span><br>        Entry[] tab = table;<br>        <span class="hljs-keyword">int</span> len = tab.length;<br>        <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span> (Entry e = tab[i];<br>             e != <span class="hljs-keyword">null</span>;<br>             e = tab[i = nextIndex(i, len)]) &#123;<br>            ThreadLocal&lt;?&gt; k = e.get();<br><br>            <span class="hljs-comment">// 下标相同，则直接赋值，新值覆盖旧值，一般一个thread的一个ThreadLocal实例，key是相同的</span><br>            <span class="hljs-keyword">if</span> (k == key) &#123;<br>                e.value = value;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;<br>                replaceStaleEntry(key, value, i);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 第一次设置值，则新建Entry</span><br>        tab[i] = <span class="hljs-keyword">new</span> Entry(key, value);<br>        <span class="hljs-keyword">int</span> sz = ++size;<br>        <span class="hljs-comment">// 清理key为null的情况，设置value为null，防止内存泄漏</span><br>        <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>            rehash();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocal本身的hashcode作为数组下标，value作为值，存在ThreadLocalMap的Entry[]中，可以保证多线程安全<br><img src="/img/threadlocal-1.png" alt="ThreadLocal源码分析图"></p><h2 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h2><p>Entry的Key是ThreadLocal，它是弱引用的</p><blockquote><p>如果一个对象只具有弱引用，那就类似于可有可无的生活用品。<br>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。<br>在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。<br>不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p></blockquote><p>一旦ThreadLocal没有被外部引用，那么垃圾回收就会回收掉Key(ThreadLocal)，这样就会导致ThreadLocalMap中key为null，<br>而value还存在着强引用，只有thead线程退出以后,value的强引用链条才会断掉。<br>但如果当前线程迟迟不结束的话，这些key为null的Entry的value就会一直存在，造成内存泄漏</p><blockquote><p>Thread Ref -&gt; Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value</p></blockquote><h3 id="防止内存泄漏的措施"><a href="#防止内存泄漏的措施" class="headerlink" title="防止内存泄漏的措施"></a>防止内存泄漏的措施</h3><ol><li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li></ol><h2 id="线程池中使用ThreadLocal的问题"><a href="#线程池中使用ThreadLocal的问题" class="headerlink" title="线程池中使用ThreadLocal的问题"></a>线程池中使用ThreadLocal的问题</h2><p>ThreadLocal是使用Thread中的ThreadLocalMap进行存储的，如果都是新线程使用起来没有问题，但是如果是线程池，还是会<br>有一些问题的，下面看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal currentUser = ThreadLocal.withInitial(() -&gt; <span class="hljs-keyword">null</span>);<br><span class="hljs-meta">@GetMapping(&quot;wrong&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">wrong</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;userId&quot;)</span> Integer userId)</span> </span>&#123; <br>    <span class="hljs-comment">//设置用户信息之前先查询一次ThreadLocal中的用户信息 </span><br>    String before = Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + currentUser.get(); <br>    <span class="hljs-comment">//设置用户信息到ThreadLocal </span><br>    currentUser.set(userId); <br>    <span class="hljs-comment">//设置用户信息之后再查询一次ThreadLocal中的用户信息 </span><br>    String after = Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + currentUser.get(); <br>    <span class="hljs-comment">//汇总输出两次查询结果 </span><br>    Map result = <span class="hljs-keyword">new</span> HashMap(); <br>    result.put(<span class="hljs-string">&quot;before&quot;</span>, before); <br>    result.put(<span class="hljs-string">&quot;after&quot;</span>, after); <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面每次请求，第一次获取的值都会是null吗？<br>其实是不一定的，可能before会有值！<br>原因是Tomcat使用了线程池，线程池会重用固定的几个线程，一旦线程重用，那么很可能首次从<code>ThreadLocal</code>获取的值是之前其他用户的请求遗留的值。<br>这时，ThreadLocal 中的用户信息就是其他用户的信息。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在代码运行结束，需要显示的清除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;right&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">right</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;userId&quot;)</span> Integer userId)</span> </span>&#123; <br>    String before = Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + currentUser.get(); <br>    currentUser.set(userId); <br>    <span class="hljs-keyword">try</span> &#123; <br>        String after = Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + currentUser.get(); <br>        Map result = <span class="hljs-keyword">new</span> HashMap(); <br>        result.put(<span class="hljs-string">&quot;before&quot;</span>, before); <br>        result.put(<span class="hljs-string">&quot;after&quot;</span>, after); <span class="hljs-keyword">return</span> result; <br>    &#125; <span class="hljs-keyword">finally</span> &#123; <br>        <span class="hljs-comment">//在finally代码块中删除ThreadLocal中的数据，确保数据不串 </span><br>        currentUser.remove(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样这个线程运行结束对应的ThreadLocal数据也清除了</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I/O 多路复用</title>
    <link href="/2022/01/05/epoll/"/>
    <url>/2022/01/05/epoll/</url>
    
    <content type="html"><![CDATA[<h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p>阻塞 I/O，是指进程发起调用后，会被挂起（阻塞），直到收到数据再返回。<br>如果调用一直不返回，进程就会一直被挂起。因此，当使用阻塞 I/O 时，需要使用多线程来处理多个文件描述符。<br><img src="/img/epoll-1.png" alt="阻塞IO"><br>从图中可以看出，从kernel到user操作都被阻塞住了，在Java中，<code>FileInputStream</code>, <code>FileOutputStream</code>以及对Socket的读写<br>都是基于阻塞IO模型。</p><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>非阻塞 I/O 不会将进程挂起，调用时会立即返回成功或错误，因此可以在一个线程里轮询多个文件描述符是否就绪。<br>但是非阻塞 I/O 的缺点是：每次发起系统调用，只能检查一个文件描述符是否就绪。当文件描述符很多时，系统调用的成本很高。<br><img src="/img/epoll-2.png" alt="非阻塞IO"></p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>I/O 多路复用，可以<code>通过一次系统调用，检查多个文件描述符的状态</code>。这是 I/O 多路复用的主要优点，<br>相比于非阻塞 I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。</p><blockquote><p>I/O 多路复用相当于将「遍历所有文件描述符、通过非阻塞 I/O 查看其是否就绪」的过程从用户线程移到了内核中，<br>由内核来负责轮询。</p></blockquote><p>进程可以通过 <code>select、poll、epoll</code> 发起 I/O 多路复用的系统调用，<br>这些系统调用都是同步阻塞的：如果传入的多个文件描述符中，有任何描述符就绪，则返回就绪的描述符；<br>否则如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞时长超过设置的 timeout 后再返回。<br>I/O 多路复用内部使用非阻塞 I/O 检查每个描述符的就绪状态。<br><img src="/img/epoll-3.png" alt="IO多路复用"></p><p><strong>IO多路复用和阻塞IO的区别：</strong></p><ol><li>I/O 多路复用引入了一些额外的操作和开销，比如要调用2次system call</li><li>用户可以在一个线程内同时处理多个 I/O 请求，而阻塞IO一个线程只能处理一个请求</li></ol><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nfds,</span></span><br><span class="hljs-params"><span class="hljs-function">            fd_set *<span class="hljs-keyword">restrict</span> readfds,</span></span><br><span class="hljs-params"><span class="hljs-function">            fd_set *<span class="hljs-keyword">restrict</span> writefds,</span></span><br><span class="hljs-params"><span class="hljs-function">            fd_set *<span class="hljs-keyword">restrict</span> errorfds,</span></span><br><span class="hljs-params"><span class="hljs-function">            struct timeval *<span class="hljs-keyword">restrict</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>readfds、writefds、errorfds 是三个文件描述符集合, select会分别监听并复值给这三个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回fd，一个连接对应一个fd</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> domain, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> protocol)</span></span><br></code></pre></td></tr></table></figure><p>socket的核心源码<br><img src="/img/epoll-4.png" alt="socket核心源码"></p><p>主要的源码解释：</p><ol><li>先声明一个 fd_set 类型的变量 readFDs, fd_set是文件描述符的集合</li><li>调用 FD_ZERO，将 readFDs 所有位 置0</li><li>调用 FD_SET，将 readFDs 感兴趣的位 置1，表示要监听这几个文件描述符</li><li>将 readFDs 传给 select，调用 select</li><li>select 会将 readFDs 中就绪的位 置1，未就绪的位 置0，返回就绪的文件描述符的数量</li><li>当 select 返回后，调用 FD_ISSET 检测给定位是否为 1，表示对应文件描述符是否就绪<br>比如进程想监听 1、2、5 这三个文件描述符，就将 readFDs 设置为 00010011，然后调用 select。<br>如果 fd=1、fd=2 就绪，而 fd=5 未就绪，select 会将 readFDs 设置为 00000011 并返回 2。</li><li>如果每个文件描述符都未就绪，select 会阻塞 timeout 时长，再返回。这期间，如果 readFDs 监听的某个文件描述符上发生可读事件，则 select 会将对应位置 1，并立即返回。</li></ol><p>select的缺点：</p><ol><li>性能开销大<ul><li>调用 select 时会陷入内核，这时需要将参数中的 fd_set 从用户空间拷贝到内核空间</li><li>内核需要遍历传递进来的所有 fd_set 的每一位，不管它们是否就绪</li></ul></li><li>同时能够监听的文件描述符数量太少。受限于 sizeof(fd_set) 的大小，在编译内核时就确定了且无法更改。一般是 1024，不同的操作系统不相同</li></ol><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 和 select 几乎没有区别, 不过在内核会转为链表方式存储，没有最大数量的限制。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。</p><p>简而言之，epoll 有以下几个特点：</p><ol><li>使用红黑树存储文件描述符集合</li><li>使用队列存储就绪的文件描述符</li><li>每个文件描述符只需在添加时传入一次；通过事件更改文件描述符状态</li><li>select、poll 模型都只使用一个函数，而 epoll 模型使用三个函数：epoll_create、epoll_ctl 和 epoll_wait。</li></ol><p>epoll 实例内部存储：</p><ul><li>监听列表：所有要监听的文件描述符，使用红黑树</li><li>就绪列表：所有就绪的文件描述符，使用链表</li></ul><p>对于“文件描述符数量少”，select 使用整型数组存储文件描述符集合，而 epoll 使用红黑树存储，数量较大。</p><p>对于“性能开销大”，epoll_ctl 中为每个文件描述符指定了回调函数，并在就绪时将其加入到就绪列表，因此 epoll 不需要像 select 那样遍历检测每个文件描述符，只需要判断就绪列表是否为空即可。这样，在没有描述符就绪时，epoll 能更早地让出系统资源。</p><p><strong>三者对比</strong></p><ol><li>select：调用开销大（需要复制集合）；集合大小有限制；需要遍历整个集合找到就绪的描述符</li><li>poll：采用链表的方式存储文件描述符，没有最大存储数量的限制，其他方面和 select 没有区别</li><li>epoll：调用开销小（不需要复制）；集合大小无限制；采用回调机制，不需要遍历整个集合</li></ol><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p><img src="/img/epoll-5.png" alt="异步IO"></p><p>异步IO就是在内核中完成操作，完成才通知到客户端</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go入门和避坑指南</title>
    <link href="/2021/10/21/go-learn/"/>
    <url>/2021/10/21/go-learn/</url>
    
    <content type="html"><![CDATA[<h3 id="nil在接口和值类型的区别"><a href="#nil在接口和值类型的区别" class="headerlink" title="nil在接口和值类型的区别"></a>nil在接口和值类型的区别</h3><p>Go的interface底层是通过<code>(type, value)</code>来实现的，<br><code>value</code>被称为接口的动态值，它是一个任意的具体值，而该<code>type</code>则为该值的类型。对于 int 值 3， 一个接口值包含 (int, 3)。<br>只有当value和type都为nil，interface才为nil。下面举例来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> p *<span class="hljs-keyword">int</span> = <span class="hljs-literal">nil</span><br>    a = p<br>    fmt.Println(a == <span class="hljs-literal">nil</span>)        <span class="hljs-comment">// false</span><br>    fmt.Println(a.(*<span class="hljs-keyword">int</span>) == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 永远返回err != nil</span><br>    <span class="hljs-keyword">if</span> err := returnError(); err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">returnsError</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>    <span class="hljs-keyword">var</span> p *MyError = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">if</span> bad() &#123;<br>        p = ErrBad<br>    &#125;<br>    <span class="hljs-keyword">return</span> p <span class="hljs-comment">// Will always return a non-nil error.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>未完待续..</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eureka源码分析</title>
    <link href="/2021/08/13/eureka/"/>
    <url>/2021/08/13/eureka/</url>
    
    <content type="html"><![CDATA[<h2 id="eureka-server"><a href="#eureka-server" class="headerlink" title="eureka server"></a>eureka server</h2><p>eureka 分为服务器和客户端，这里先分析服务器端的主要代码</p><h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p>Spring Cloud 的<code>eureka</code>利用了 Spring Boot 提供的自动装配功能</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span><br><span class="hljs-string">  org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration</span><br></code></pre></td></tr></table></figure><p>Spring启动的时候加载<code>EurekaServerAutoConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-comment">// 实例化并加入Spring容器</span><br><span class="hljs-meta">@Import(EurekaServerInitializerConfiguration.class)</span><br><span class="hljs-comment">// 条件注入的前提条件</span><br><span class="hljs-meta">@ConditionalOnBean(EurekaServerMarkerConfiguration.Marker.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123; EurekaDashboardProperties.class, InstanceRegistryProperties.class &#125;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:/eureka/server.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaServerAutoConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>注入的条件是来自EurekaServerMarkerConfiguration的 Marker, 看一下这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaServerMarkerConfiguration</span> </span>&#123;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Marker <span class="hljs-title">eurekaServerMarkerBean</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Marker();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Marker</span> </span>&#123;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现需要EurekaServerMarkerConfiguration去初始化这个Marker，<br>而EurekaServerMarkerConfiguration的初始化可以从下面的EnableEurekaServer来完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-comment">// 实例化并加入Spring容器，这样Marker也能实例化了</span><br><span class="hljs-meta">@Import(EurekaServerMarkerConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableEurekaServer &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>只有添加了<code>@EnableEurekaServer</code>注解，才会有后面的动作，这是成为一个eureka server的前提</p><h3 id="主要配置类和初始化"><a href="#主要配置类和初始化" class="headerlink" title="主要配置类和初始化"></a>主要配置类和初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化仪表盘, eureka.dashboard.enabled=false 则可以关闭</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;eureka.dashboard&quot;, name = &quot;enabled&quot;, matchIfMissing = true)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> EurekaController <span class="hljs-title">eurekaController</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EurekaController(<span class="hljs-keyword">this</span>.applicationInfoManager);<br>&#125;<br><span class="hljs-comment">// 集群模式下使用的注册器，eureka集群下每个节点是对等的</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> PeerAwareInstanceRegistry <span class="hljs-title">peerAwareInstanceRegistry</span><span class="hljs-params">(ServerCodecs serverCodecs)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.eurekaClient.getApplications(); <span class="hljs-comment">// force initialization</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InstanceRegistry(<span class="hljs-keyword">this</span>.eurekaServerConfig, <span class="hljs-keyword">this</span>.eurekaClientConfig, serverCodecs, <span class="hljs-keyword">this</span>.eurekaClient,<br>    <span class="hljs-keyword">this</span>.instanceRegistryProperties.getExpectedNumberOfClientsSendingRenews(),<br>    <span class="hljs-keyword">this</span>.instanceRegistryProperties.getDefaultOpenForTrafficCount());<br>&#125;<br><span class="hljs-comment">// 封装对等节点的相关操作</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> PeerEurekaNodes <span class="hljs-title">peerEurekaNodes</span><span class="hljs-params">(PeerAwareInstanceRegistry registry, ServerCodecs serverCodecs,</span></span><br><span class="hljs-params"><span class="hljs-function">    ReplicationClientAdditionalFilters replicationClientAdditionalFilters)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RefreshablePeerEurekaNodes(registry, <span class="hljs-keyword">this</span>.eurekaServerConfig, <span class="hljs-keyword">this</span>.eurekaClientConfig, serverCodecs,<br>    <span class="hljs-keyword">this</span>.applicationInfoManager, replicationClientAdditionalFilters);<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> EurekaServerContext <span class="hljs-title">eurekaServerContext</span><span class="hljs-params">(ServerCodecs serverCodecs, PeerAwareInstanceRegistry registry,</span></span><br><span class="hljs-params"><span class="hljs-function">    PeerEurekaNodes peerEurekaNodes)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultEurekaServerContext(<span class="hljs-keyword">this</span>.eurekaServerConfig, serverCodecs, registry, peerEurekaNodes,<br>    <span class="hljs-keyword">this</span>.applicationInfoManager);<br>&#125;<br><br><span class="hljs-comment">// 启动使用类</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> EurekaServerBootstrap <span class="hljs-title">eurekaServerBootstrap</span><span class="hljs-params">(PeerAwareInstanceRegistry registry,</span></span><br><span class="hljs-params"><span class="hljs-function">    EurekaServerContext serverContext)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EurekaServerBootstrap(<span class="hljs-keyword">this</span>.applicationInfoManager, <span class="hljs-keyword">this</span>.eurekaClientConfig, <span class="hljs-keyword">this</span>.eurekaServerConfig,<br>    registry, serverContext);<br>&#125;<br><span class="hljs-comment">// 使用jersey框架来提供rest服务</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> FilterRegistrationBean&lt;?&gt; jerseyFilterRegistration(javax.ws.rs.core.Application eurekaJerseyApp) &#123;<br>    FilterRegistrationBean&lt;Filter&gt; bean = <span class="hljs-keyword">new</span> FilterRegistrationBean&lt;Filter&gt;();<br>    bean.setFilter(<span class="hljs-keyword">new</span> ServletContainer(eurekaJerseyApp));<br>    bean.setOrder(Ordered.LOWEST_PRECEDENCE);<br>    bean.setUrlPatterns(Collections.singletonList(EurekaConstants.DEFAULT_PREFIX + <span class="hljs-string">&quot;/*&quot;</span>));<br><br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续看<code>PeerEurekaNodes</code>的start方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeerEurekaNodes</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        taskExecutor = Executors.newSingleThreadScheduledExecutor(<br>                <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>                        Thread thread = <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;Eureka-PeerNodesUpdater&quot;</span>);<br>                        thread.setDaemon(<span class="hljs-keyword">true</span>);<br>                        <span class="hljs-keyword">return</span> thread;<br>                    &#125;<br>                &#125;<br>        );<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 更新对等的节点信息，在DefaultEurekaServerContext中调用</span><br>            updatePeerEurekaNodes(resolvePeerUrls());<br>            Runnable peersUpdateTask = <span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        updatePeerEurekaNodes(resolvePeerUrls());<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>                        logger.error(<span class="hljs-string">&quot;Cannot update the replica Nodes&quot;</span>, e);<br>                    &#125;<br><br>                &#125;<br>            &#125;;<br>            taskExecutor.scheduleWithFixedDelay(<br>                    peersUpdateTask,<br>                    serverConfig.getPeerEurekaNodesUpdateIntervalMs(),<br>                    serverConfig.getPeerEurekaNodesUpdateIntervalMs(),<br>                    TimeUnit.MILLISECONDS<br>            );<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(e);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (PeerEurekaNode node : peerEurekaNodes) &#123;<br>            logger.info(<span class="hljs-string">&quot;Replica node URL:  &#123;&#125;&quot;</span>, node.getServiceUrl());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>DefaultEurekaServerContext</code>是eureka server的默认上下文，这边就会获取其他的服务节点信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultEurekaServerContext</span> </span>&#123;<br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;Initializing ...&quot;</span>);<br>        peerEurekaNodes.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 初始化</span><br>            registry.init(peerEurekaNodes);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>        logger.info(<span class="hljs-string">&quot;Initialized&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点看eureka的初始化过程，在eureka server启动过程中，继承了<code>smartLifecycle</code>，这样可以在Bean初始化完做一些事情，<br>在syncUp方法中，会获取其他eureka server的注册信息，并保存到本地的register中，结构是 <code>ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeerAwareInstanceRegistryImpl</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">syncUp</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// Copy entire entry from neighboring DS node</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 重试，循环获取其他server的注册信息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; ((i &lt; serverConfig.getRegistrySyncRetries()) &amp;&amp; (count == <span class="hljs-number">0</span>)); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(serverConfig.getRegistrySyncRetryWaitMs());<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    logger.warn(<span class="hljs-string">&quot;Interrupted during registry transfer..&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 获取其他的server注册信息</span><br>            Applications apps = eurekaClient.getApplications();<br>            <span class="hljs-keyword">for</span> (Application app : apps.getRegisteredApplications()) &#123;<br>                <span class="hljs-keyword">for</span> (InstanceInfo instance : app.getInstances()) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (isRegisterable(instance)) &#123;<br>                            <span class="hljs-comment">// 注册到自己的map中，作为本地缓存</span><br>                            register(instance, instance.getLeaseInfo().getDurationInSecs(), <span class="hljs-keyword">true</span>);<br>                            count++;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                        logger.error(<span class="hljs-string">&quot;During DS init copy&quot;</span>, t);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeerAwareInstanceRegistryImpl</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openForTraffic</span><span class="hljs-params">(ApplicationInfoManager applicationInfoManager, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-comment">// Renewals happen every 30 seconds and for a minute it should be a factor of 2.</span><br>        <span class="hljs-keyword">this</span>.expectedNumberOfClientsSendingRenews = count;<br>        updateRenewsPerMinThreshold();<br>        logger.info(<span class="hljs-string">&quot;Got &#123;&#125; instances from neighboring DS node&quot;</span>, count);<br>        logger.info(<span class="hljs-string">&quot;Renew threshold is: &#123;&#125;&quot;</span>, numberOfRenewsPerMinThreshold);<br>        <span class="hljs-keyword">this</span>.startupTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">this</span>.peerInstancesTransferEmptyOnStartup = <span class="hljs-keyword">false</span>;<br>        &#125;<br>        DataCenterInfo.Name selfName = applicationInfoManager.getInfo().getDataCenterInfo().getName();<br>        <span class="hljs-keyword">boolean</span> isAws = Name.Amazon == selfName;<br>        <span class="hljs-keyword">if</span> (isAws &amp;&amp; serverConfig.shouldPrimeAwsReplicaConnections()) &#123;<br>            logger.info(<span class="hljs-string">&quot;Priming AWS connections for all replicas..&quot;</span>);<br>            primeAwsReplicas(applicationInfoManager);<br>        &#125;<br>        logger.info(<span class="hljs-string">&quot;Changing status to UP&quot;</span>);<br>        <span class="hljs-comment">// 实例状态改为UP</span><br>        applicationInfoManager.setInstanceStatus(InstanceStatus.UP);<br>        <span class="hljs-comment">// 开启定时任务，每60秒进行服务失败剔除</span><br>        <span class="hljs-keyword">super</span>.postInit();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="服务注册过程"><a href="#服务注册过程" class="headerlink" title="服务注册过程"></a>服务注册过程</h3><ol><li>首先通过Jersey的接口监听注册请求</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationResource</span> </span>&#123;<br>    <span class="hljs-comment">// 供客户端进行服务注册的接口</span><br>    <span class="hljs-meta">@POST</span><br>    <span class="hljs-meta">@Consumes(&#123;&quot;application/json&quot;, &quot;application/xml&quot;&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">addInstance</span><span class="hljs-params">(InstanceInfo info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-meta">@HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 在这边注册</span><br>        registry.register(info, <span class="hljs-string">&quot;true&quot;</span>.equals(isReplication));<br>        <span class="hljs-keyword">return</span> Response.status(<span class="hljs-number">204</span>).build();  <span class="hljs-comment">// 204 to be backwards compatible</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>调用<code>register</code>方法注册到本地缓存</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeerAwareInstanceRegistryImpl</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">final</span> InstanceInfo info, <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isReplication)</span> </span>&#123;<br>        <span class="hljs-comment">// 服务失效间隔【检查间隔】默认90s</span><br>        <span class="hljs-keyword">int</span> leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;<br>        <span class="hljs-keyword">if</span> (info.getLeaseInfo() != <span class="hljs-keyword">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 配置文件为准</span><br>            leaseDuration = info.getLeaseInfo().getDurationInSecs();<br>        &#125;<br>        <span class="hljs-keyword">super</span>.register(info, leaseDuration, isReplication);<br>        <span class="hljs-comment">// 当前server把该注册信息同步到其他节点</span><br>        replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, <span class="hljs-keyword">null</span>, isReplication);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>super.register</code>主要是注册节点到本地缓存的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractInstanceRegistry</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(InstanceInfo registrant, <span class="hljs-keyword">int</span> leaseDuration, <span class="hljs-keyword">boolean</span> isReplication)</span> </span>&#123;<br>        read.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());<br>            REGISTER.increment(isReplication);<br>            <span class="hljs-keyword">if</span> (gMap == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;();<br>                gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);<br>                <span class="hljs-keyword">if</span> (gMap == <span class="hljs-keyword">null</span>) &#123;<br>                    gMap = gNewMap;<br>                &#125;<br>            &#125;<br>            Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());<br>            <span class="hljs-comment">// ...</span><br>            Lease&lt;InstanceInfo&gt; lease = <span class="hljs-keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);<br>            <span class="hljs-keyword">if</span> (existingLease != <span class="hljs-keyword">null</span>) &#123;<br>                lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());<br>            &#125;<br>            <span class="hljs-comment">// 设置实例到本地缓存</span><br>            gMap.put(registrant.getId(), lease);<br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            read.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>把该注册信息同步到其他节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replicateToPeers</span><span class="hljs-params">(Action action, String appName, String id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  InstanceInfo info <span class="hljs-comment">/* optional */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  InstanceStatus newStatus <span class="hljs-comment">/* optional */</span>, <span class="hljs-keyword">boolean</span> isReplication)</span> </span>&#123;<br>        Stopwatch tracer = action.getTimer().start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (isReplication) &#123;<br>                numberOfReplicationsLastMin.increment();<br>            &#125;<br>            <span class="hljs-comment">// If it is a replication already, do not replicate again as this will create a poison replication</span><br>            <span class="hljs-keyword">if</span> (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) &#123;<br>                <span class="hljs-comment">// If the url represents this host, do not replicate to yourself.</span><br>                <span class="hljs-comment">// 判断是否是当前节点，如果是则不用同步了【之前初始化已经同步过了】</span><br>                <span class="hljs-keyword">if</span> (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 对等节点动作</span><br>                replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            tracer.stop();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replicateInstanceActionsToPeers</span><span class="hljs-params">(Action action, String appName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 String id, InstanceInfo info, InstanceStatus newStatus,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 PeerEurekaNode node)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            InstanceInfo infoFromRegistry;<br>            CurrentRequestVersion.set(Version.V2);<br>            <span class="hljs-keyword">switch</span> (action) &#123;<br>                <span class="hljs-keyword">case</span> Cancel:<br>                    node.cancel(appName, id);<br>                    <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-comment">// 心跳</span><br>                <span class="hljs-keyword">case</span> Heartbeat:<br>                    InstanceStatus overriddenStatus = overriddenInstanceStatusMap.get(id);<br>                    infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="hljs-keyword">false</span>);<br>                    node.heartbeat(appName, id, infoFromRegistry, overriddenStatus, <span class="hljs-keyword">false</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-comment">// 注册</span><br>                <span class="hljs-keyword">case</span> Register:<br>                    node.register(info);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> StatusUpdate:<br>                    infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="hljs-keyword">false</span>);<br>                    node.statusUpdate(appName, id, newStatus, infoFromRegistry);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> DeleteStatusOverride:<br>                    infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="hljs-keyword">false</span>);<br>                    node.deleteStatusOverride(appName, id, infoFromRegistry);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            logger.error(<span class="hljs-string">&quot;Cannot replicate information to &#123;&#125; for action &#123;&#125;&quot;</span>, node.getServiceUrl(), action.name(), t);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            CurrentRequestVersion.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>心跳【续约】接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceResource</span> </span>&#123;<br>    <span class="hljs-comment">// 续约接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">renewLease</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> isFromReplicaNode = <span class="hljs-string">&quot;true&quot;</span>.equals(isReplication);<br>        <span class="hljs-keyword">boolean</span> isSuccess = registry.renew(app.getName(), id, isFromReplicaNode);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这边调用了registry.renew方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeerAwareInstanceRegistryImpl</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">renew</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String appName, <span class="hljs-keyword">final</span> String id, <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isReplication)</span> </span>&#123;<br>        <span class="hljs-comment">// super.renew 里面会调用 --&gt; lastUpdateTimestamp = System.currentTimeMillis() + duration;</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">super</span>.renew(appName, id, isReplication)) &#123;<br>            <span class="hljs-comment">// Action.Heartbeat表示心跳，再一次调用了这个方法</span><br>            <span class="hljs-comment">// renew同步到其他节点</span><br>            replicateToPeers(Action.Heartbeat, appName, id, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, isReplication);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="eureka-client"><a href="#eureka-client" class="headerlink" title="eureka client"></a>eureka client</h2><p>eureka client会注册到server端，并且发送心跳给服务器端。<br>client在启动的时候需要</p><ol><li>读取配置文件</li><li>注册到server</li><li>开启定时任务发送心跳，<strong>主动拉取</strong>server的注册信息刷新到本地的缓存【eureka不会主动推送】</li></ol><h3 id="自动装配和注册"><a href="#自动装配和注册" class="headerlink" title="自动装配和注册"></a>自动装配和注册</h3><ol><li>自动装配初始化配置类，读取配置文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@EnableConfigurationProperties</span><br><span class="hljs-meta">@ConditionalOnClass(EurekaClientConfig.class)</span><br><span class="hljs-comment">// eureka.client.enabled = false, 则不会成为客户端</span><br><span class="hljs-meta">@ConditionalOnProperty(value = &quot;eureka.client.enabled&quot;, matchIfMissing = true)</span><br><span class="hljs-meta">@ConditionalOnDiscoveryEnabled</span><br><span class="hljs-meta">@AutoConfigureBefore(&#123; CommonsClientAutoConfiguration.class, ServiceRegistryAutoConfiguration.class &#125;)</span><br><span class="hljs-comment">// 配置完毕AutoConfigureAfter再装配EurekaClientAutoConfiguration</span><br><span class="hljs-meta">@AutoConfigureAfter(name = &#123; &quot;org.springframework.cloud.netflix.eureka.config.DiscoveryClientOptionalArgsConfiguration&quot;,</span><br><span class="hljs-meta">&quot;org.springframework.cloud.autoconfigure.RefreshAutoConfiguration&quot;,</span><br><span class="hljs-meta">&quot;org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration&quot;,</span><br><span class="hljs-meta">&quot;org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationAutoConfiguration&quot; &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaClientAutoConfiguration</span> </span>&#123;<br>    <span class="hljs-comment">// 读取配置信息</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(value = EurekaInstanceConfig.class, search = SearchStrategy.CURRENT)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> EurekaInstanceConfigBean <span class="hljs-title">eurekaInstanceConfigBean</span><span class="hljs-params">(InetUtils inetUtils,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                             ManagementMetadataProvider managementMetadataProvider)</span> </span>&#123;<br>        String hostname = getProperty(<span class="hljs-string">&quot;eureka.instance.hostname&quot;</span>);<br>        <span class="hljs-keyword">boolean</span> preferIpAddress = Boolean.parseBoolean(getProperty(<span class="hljs-string">&quot;eureka.instance.prefer-ip-address&quot;</span>));<br>        String ipAddress = getProperty(<span class="hljs-string">&quot;eureka.instance.ip-address&quot;</span>);<br>        <span class="hljs-keyword">boolean</span> isSecurePortEnabled = Boolean.parseBoolean(getProperty(<span class="hljs-string">&quot;eureka.instance.secure-port-enabled&quot;</span>));<br><br>        String serverContextPath = env.getProperty(<span class="hljs-string">&quot;server.servlet.context-path&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-keyword">int</span> serverPort = Integer.parseInt(env.getProperty(<span class="hljs-string">&quot;server.port&quot;</span>, env.getProperty(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>)));<br><br>        Integer managementPort = env.getProperty(<span class="hljs-string">&quot;management.server.port&quot;</span>, Integer.class);<br><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>在DiscoveryClient的初始化中，获取server的注册信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscoveryClient</span> </span>&#123;<br>    <span class="hljs-meta">@Inject</span><br>    DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,<br>                    Provider&lt;BackupRegistry&gt; backupRegistryProvider, EndpointRandomizer endpointRandomizer) &#123;<br>        <span class="hljs-comment">// 判断要不要注册</span><br>        <span class="hljs-keyword">if</span> (!config.shouldRegisterWithEureka() &amp;&amp; !config.shouldFetchRegistry()) &#123;<br>            <br>        &#125;<br>        <span class="hljs-comment">// 判断要不要获取注册信息</span><br>        <span class="hljs-keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;<br>            <span class="hljs-keyword">boolean</span> primaryFetchRegistryResult = fetchRegistry(<span class="hljs-keyword">false</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">fetchRegistry</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> forceFullRegistryFetch)</span> </span>&#123;<br>        Stopwatch tracer = FETCH_REGISTRY_TIMER.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// If the delta is disabled or if it is the first time, get all</span><br>            <span class="hljs-comment">// applications</span><br>            <span class="hljs-comment">// 获取本地缓存</span><br>            Applications applications = getApplications();<br><br>            <span class="hljs-comment">// 全量获取</span><br>            <span class="hljs-keyword">if</span> (clientConfig.shouldDisableDelta()<br>                    || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))<br>                    || forceFullRegistryFetch<br>                    || (applications == <span class="hljs-keyword">null</span>)<br>                    || (applications.getRegisteredApplications().size() == <span class="hljs-number">0</span>)<br>                    || (applications.getVersion() == -<span class="hljs-number">1</span>)) <span class="hljs-comment">//Client application does not have latest library supporting delta</span><br>            &#123;<br>                logger.info(<span class="hljs-string">&quot;Disable delta property : &#123;&#125;&quot;</span>, clientConfig.shouldDisableDelta());<br>                logger.info(<span class="hljs-string">&quot;Single vip registry refresh property : &#123;&#125;&quot;</span>, clientConfig.getRegistryRefreshSingleVipAddress());<br>                logger.info(<span class="hljs-string">&quot;Force full registry fetch : &#123;&#125;&quot;</span>, forceFullRegistryFetch);<br>                logger.info(<span class="hljs-string">&quot;Application is null : &#123;&#125;&quot;</span>, (applications == <span class="hljs-keyword">null</span>));<br>                logger.info(<span class="hljs-string">&quot;Registered Applications size is zero : &#123;&#125;&quot;</span>,<br>                        (applications.getRegisteredApplications().size() == <span class="hljs-number">0</span>));<br>                logger.info(<span class="hljs-string">&quot;Application version is -1: &#123;&#125;&quot;</span>, (applications.getVersion() == -<span class="hljs-number">1</span>));<br>                getAndStoreFullRegistry();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 增量获取</span><br>                getAndUpdateDelta(applications);<br>            &#125;<br>            applications.setAppsHashCode(applications.getReconcileHashCode());<br>            logTotalInstances();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            logger.info(PREFIX + <span class="hljs-string">&quot;&#123;&#125; - was unable to refresh its cache! This periodic background refresh will be retried in &#123;&#125; seconds. status = &#123;&#125; stacktrace = &#123;&#125;&quot;</span>,<br>                    appPathIdentifier, clientConfig.getRegistryFetchIntervalSeconds(), e.getMessage(), ExceptionUtils.getStackTrace(e));<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (tracer != <span class="hljs-keyword">null</span>) &#123;<br>                tracer.stop();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Notify about cache refresh before updating the instance remote status</span><br>        onCacheRefreshed();<br><br>        <span class="hljs-comment">// Update remote status based on refreshed data held in the cache</span><br>        updateInstanceRemoteStatus();<br><br>        <span class="hljs-comment">// registry was fetched successfully, so return true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>在全量获取的时候，使用了jersey框架获取了applications信息，然后使用了乐观锁设置到本地缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAndStoreFullRegistry</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    <span class="hljs-comment">// AtomicLong 作为乐观锁</span><br>    <span class="hljs-keyword">long</span> currentUpdateGeneration = fetchRegistryGeneration.get();<br><br>    logger.info(<span class="hljs-string">&quot;Getting all instance registry info from the eureka server&quot;</span>);<br><br>    Applications apps = <span class="hljs-keyword">null</span>;<br>    EurekaHttpResponse&lt;Applications&gt; httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == <span class="hljs-keyword">null</span><br>        <span class="hljs-comment">// 请求服务器获取</span><br>            ? eurekaTransport.queryClient.getApplications(remoteRegionsRef.get())<br>            : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress(), remoteRegionsRef.get());<br>    <span class="hljs-keyword">if</span> (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123;<br>        apps = httpResponse.getEntity();<br>    &#125;<br>    logger.info(<span class="hljs-string">&quot;The response status is &#123;&#125;&quot;</span>, httpResponse.getStatusCode());<br><br>    <span class="hljs-keyword">if</span> (apps == <span class="hljs-keyword">null</span>) &#123;<br>        logger.error(<span class="hljs-string">&quot;The application is null for some reason. Not storing this information&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-comment">// 洗牌随机算法设置缓存</span><br>        localRegionApps.set(<span class="hljs-keyword">this</span>.filterAndShuffle(apps));<br>        logger.debug(<span class="hljs-string">&quot;Got full registry with apps hashcode &#123;&#125;&quot;</span>, apps.getAppsHashCode());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        logger.warn(<span class="hljs-string">&quot;Not updating applications as another thread is updating it already&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>注册自己</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">register</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    logger.info(PREFIX + <span class="hljs-string">&quot;&#123;&#125;: registering service...&quot;</span>, appPathIdentifier);<br>    EurekaHttpResponse&lt;Void&gt; httpResponse;<br>    <span class="hljs-keyword">try</span> &#123;<br>        httpResponse = eurekaTransport.registrationClient.register(instanceInfo);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        logger.warn(PREFIX + <span class="hljs-string">&quot;&#123;&#125; - registration failed &#123;&#125;&quot;</span>, appPathIdentifier, e.getMessage(), e);<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>        logger.info(PREFIX + <span class="hljs-string">&quot;&#123;&#125; - registration status: &#123;&#125;&quot;</span>, appPathIdentifier, httpResponse.getStatusCode());<br>    &#125;<br>    <span class="hljs-keyword">return</span> httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>定时器获取注册信息和发送心跳</li></ol><p>回到<code>DiscoveryClient</code>的构造方法，调用完fetchRegistry方法之后会执行<code>initScheduledTasks</code>方法，作为定时器的初始化，<br>定时任务基本和之前初始化获取注册信息<code>instance</code>一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">refreshRegistry</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 重新获取注册信息，和之前的</span><br>    <span class="hljs-keyword">boolean</span> success = fetchRegistry(remoteRegionsModified); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">renew</span><span class="hljs-params">()</span> </span>&#123;<br>    EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;<br>    <span class="hljs-keyword">try</span> &#123;<br>        httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="hljs-keyword">null</span>);<br>        logger.debug(PREFIX + <span class="hljs-string">&quot;&#123;&#125; - Heartbeat status: &#123;&#125;&quot;</span>, appPathIdentifier, httpResponse.getStatusCode());<br>        <span class="hljs-comment">// 找不到则被eureka service剔除</span><br>        <span class="hljs-keyword">if</span> (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) &#123;<br>            REREGISTER_COUNTER.increment();<br>            logger.info(PREFIX + <span class="hljs-string">&quot;&#123;&#125; - Re-registering apps/&#123;&#125;&quot;</span>, appPathIdentifier, instanceInfo.getAppName());<br>            <span class="hljs-keyword">long</span> timestamp = instanceInfo.setIsDirtyWithTime();<br>            <span class="hljs-comment">// 重新注册自己</span><br>            <span class="hljs-keyword">boolean</span> success = register();<br>            <span class="hljs-keyword">if</span> (success) &#123;<br>                instanceInfo.unsetIsDirty(timestamp);<br>            &#125;<br>            <span class="hljs-keyword">return</span> success;<br>        &#125;<br>        <span class="hljs-keyword">return</span> httpResponse.getStatusCode() == Status.OK.getStatusCode();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        logger.error(PREFIX + <span class="hljs-string">&quot;&#123;&#125; - was unable to send heartbeat!&quot;</span>, appPathIdentifier, e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>服务主动下线会调用清理定时任务和server下架操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unregister</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// It can be null if shouldRegisterWithEureka == false</span><br>    <span class="hljs-keyword">if</span>(eurekaTransport != <span class="hljs-keyword">null</span> &amp;&amp; eurekaTransport.registrationClient != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            logger.info(<span class="hljs-string">&quot;Unregistering ...&quot;</span>);<br>            EurekaHttpResponse&lt;Void&gt; httpResponse = eurekaTransport.registrationClient.cancel(instanceInfo.getAppName(), instanceInfo.getId());<br>            logger.info(PREFIX + <span class="hljs-string">&quot;&#123;&#125; - deregister  status: &#123;&#125;&quot;</span>, appPathIdentifier, httpResponse.getStatusCode());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            logger.error(PREFIX + <span class="hljs-string">&quot;&#123;&#125; - de-registration failed&#123;&#125;&quot;</span>, appPathIdentifier, e.getMessage(), e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring cloud</tag>
      
      <tag>eureka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raft算法</title>
    <link href="/2021/07/28/raft/"/>
    <url>/2021/07/28/raft/</url>
    
    <content type="html"><![CDATA[<h3 id="raft算法简介"><a href="#raft算法简介" class="headerlink" title="raft算法简介"></a>raft算法简介</h3><p>raft算法是Paxos算法的工程实现，主要特点就是通过较为简单的算法实现分布式系统的数据一致性和高可用，<br>Raft通过选举一个领导人，然后给予他全部的管理复制日志的责任来实现一致性。<br>Raft算法中任何服务器都可以扮演下面的角色之一:</p><ol><li>领导者(leader): 处理客户端交互，日志复制等动作，一般一次只有一个领导者</li><li>候选者(candidate): 候选者就是在选举过程中提名自己的实体，一旦选举成功，则成为领导者</li><li>跟随者(follower): 类似选民，完全被动的角色，这样的服务器等待被通知投票</li></ol><p>他们之间的身份变化如下图<br><img src="/img/raft-election.png" alt="raft算法角色变化"></p><h3 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h3><ol><li>初始状态下集群中的所有节点都处于 <code>follower</code> 状态</li></ol><p><img src="/img/raft-election1.png" alt="初始状态"></p><ol start="2"><li>某一时刻，其中的一个 <code>follower</code> 由于没有收到 <code>leader</code> 的 <code>heartbeat</code> 率先发生 <code>election timeout</code> 进而发起选举</li></ol><p><img src="/img/raft-election2.png" alt="某一时刻发起选取"></p><ol start="3"><li>只要集群中超过半数的节点接受投票，<code>candidate</code> 节点将成为即切换 <code>leader</code> 状态</li></ol><p><img src="/img/raft-election3.png" alt="超过半数选取为新leader"></p><ol start="4"><li>成为 <code>leader</code> 节点之后，<code>leader</code> 将定时向 <code>follower</code> 节点同步日志并发送 <code>heartbeat</code></li></ol><p><img src="/img/raft-election4.png" alt="同步日志并发送心跳"></p><h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>raft协议的 <code>log replication</code>  有点类似 2PC ，但是不同的是raft只要求大多数节点的回复即可，raft保证的是最终一致性<br>leader会不断尝试给follower发log entries，直到所有节点的log entries都相同。</p><p><strong>Raft 协议要求投票只能投给拥有最新数据的节点</strong>, 保证了在同步log的时候leader挂掉，重新选举leader的时候，数据不丢失</p><p><img src="/img/raft-replication.png" alt="Raft日志复制过程.png"></p><p>主要步骤如下:</p><ol><li>客户端的每一个请求都包含被复制状态机执行的指令。 </li><li>leader把这个指令作为一条新的日志条目添加到日志中，然后并行发起 RPC 给其他的服务器，让他们复制这 条信息。</li><li>跟随者响应ACK,如果 follower 宕机或者运行缓慢或者丢包，leader会不断的重试，直到所有的 follower 最终 都复制了所有的日志条目。 </li><li>通知所有的Follower提交日志，同时领导人提交这条日志到自己的状态机中，并返回给客户端。</li><li>如果committed状态后client未收到leader响应，则client会重新发送请求，需要做幂等保证一致性。</li><li>如果leader在发送commit给从节点之前挂掉，就会导致从节点存在<code>uncommitted log</code>，这时候会重新选举，<br>按照raft协议，新leader会包含之前leader的最新log，并且在新的term下，<strong>commit新的entry时</strong>，就会一并把前leader前term的前entry也提交了，于是所有状态机就一致了</li></ol><h3 id="脑裂情况"><a href="#脑裂情况" class="headerlink" title="脑裂情况"></a>脑裂情况</h3><p>raft也可以保证在脑裂情况保证数据的一致性</p><p><img src="/img/brain.png" alt="脑裂情况图示"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://thesecretlivesofdata.com/raft/">raft动画</a></p><p><a href="https://raft.github.io/#implementations">raft演示</a></p><p><a href="https://www.cnblogs.com/mindwind/p/5231986.html">raft复制日志各状态分析</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>raft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广度优先</title>
    <link href="/2021/07/27/bfs/"/>
    <url>/2021/07/27/bfs/</url>
    
    <content type="html"><![CDATA[<h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3><p>BFS 相对 DFS 的最主要的区别是：BFS找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多</p><p>使用BFS可以求出最短路径</p><h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.add(node);<br>        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最短路径</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            depth++;<br>            <span class="hljs-keyword">int</span> size = queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                node = queue.poll();<br>                <span class="hljs-comment">// 相邻节点加入队列</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-comment">// 某些条件) &#123;</span><br>                    queue.add();<br>                &#125;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">Leetcode 二叉树的最小深度</a></p><p>这道题就是典型的求最短路径，使用BFS解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.add(root);<br>        <span class="hljs-comment">// 定义最短路径</span><br>        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            depth++;<br>            <span class="hljs-keyword">int</span> size = queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode node = queue.poll();<br>                <span class="hljs-comment">// 找到了叶子节点</span><br>                <span class="hljs-keyword">if</span> (node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> depth;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/rotting-oranges/">Leetcode 腐烂的橘子</a><br>这道题采用了多源出发点，首先需要找到所有腐烂的橘子作为出发点，然后使用BFS找到最短的路径，<br>如果遍历结束仍然有新鲜的橘子，则返回-1，否则返回最短路径</p><p>注意终止条件需要加上新鲜橘子为0的情况，为0表示所有橘子都变为腐烂，已经找到了最短路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>        Queue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 新鲜橘子的个数</span><br>        <span class="hljs-keyword">int</span> M = grid.length;<br>        <span class="hljs-keyword">int</span> N = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; M; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    count++;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">2</span>) &#123;<br>                    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示腐烂的轮数，或者分钟数</span><br>        <span class="hljs-comment">// 新鲜橘子个数为0，则不需要再遍历了</span><br>        <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span> &amp;&amp; !queue.isEmpty()) &#123;<br>            depth++;<br>            <span class="hljs-keyword">int</span> size = queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-keyword">int</span>[] rotten = queue.poll();<br>                <span class="hljs-keyword">int</span> r = rotten[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> c = rotten[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (r &gt; <span class="hljs-number">0</span> &amp;&amp; grid[r-<span class="hljs-number">1</span>][c] == <span class="hljs-number">1</span>) &#123;<br>                    grid[r-<span class="hljs-number">1</span>][c] = <span class="hljs-number">2</span>;<br>                    count--;<br>                    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;r-<span class="hljs-number">1</span>, c&#125;);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (r + <span class="hljs-number">1</span> &lt; M &amp;&amp; grid[r+<span class="hljs-number">1</span>][c] == <span class="hljs-number">1</span>) &#123;<br>                    grid[r+<span class="hljs-number">1</span>][c] = <span class="hljs-number">2</span>;<br>                    count--;<br>                    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;r+<span class="hljs-number">1</span>, c&#125;);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span> &amp;&amp; grid[r][c-<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                    grid[r][c-<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>                    count--;<br>                    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;r, c-<span class="hljs-number">1</span>&#125;);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; N &amp;&amp; grid[r][c+<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                    grid[r][c+<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>                    count--;<br>                    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;r, c+<span class="hljs-number">1</span>&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>广度优先</tag>
      
      <tag>算法</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>session一致性</title>
    <link href="/2021/07/26/session/"/>
    <url>/2021/07/26/session/</url>
    
    <content type="html"><![CDATA[<h3 id="session在分布式环境下的问题"><a href="#session在分布式环境下的问题" class="headerlink" title="session在分布式环境下的问题"></a>session在分布式环境下的问题</h3><p>Session在集群情况下，可能会发生不一致的问题，即Session不能在多机器共享</p><p><img src="/img/session.png" alt="Session不一致问题"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-使用Nginx的ip-hash-保证同一个ip请求同一个实例"><a href="#1-使用Nginx的ip-hash-保证同一个ip请求同一个实例" class="headerlink" title="1. 使用Nginx的ip_hash 保证同一个ip请求同一个实例"></a>1. 使用Nginx的<code>ip_hash</code> 保证同一个ip请求同一个实例</h4><p>优点:</p><ul><li>配置简单，不入侵应用，不需要额外修改代码</li></ul><p>缺点:</p><ul><li>服务器重启，Session会丢失，因为Session本质上保存在服务器内存中</li><li>单点负载，故障风险</li></ul><h4 id="2-使用Redis统一保存Session"><a href="#2-使用Redis统一保存Session" class="headerlink" title="2. 使用Redis统一保存Session"></a>2. 使用Redis统一保存Session</h4><p>优点:</p><ul><li>能适应各种负载均衡策略 </li><li>服务器重启或者宕机不会造成Session丢失 </li><li>扩展能力强</li><li>适合大集群数量使用</li></ul><p>使用<code>Spring Session</code>可以非常方便的实现Redis管理Session</p><ol><li><p>引入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置redis</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure></li><li><p>添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableRedisHttpSession</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringApplication</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>源码分析</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 其实就是自定义了一个filter</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionRepositoryFilter</span>&lt;<span class="hljs-title">S</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Session</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// 请求中只会调用一次</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        request.setAttribute(SESSION_REPOSITORY_ATTR, <span class="hljs-keyword">this</span>.sessionRepository);<br><br>        SessionRepositoryRequestWrapper wrappedRequest = <span class="hljs-keyword">new</span> SessionRepositoryRequestWrapper(<br>                request, response, <span class="hljs-keyword">this</span>.servletContext);<br>        SessionRepositoryResponseWrapper wrappedResponse = <span class="hljs-keyword">new</span> SessionRepositoryResponseWrapper(<br>                wrappedRequest, response);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            filterChain.doFilter(wrappedRequest, wrappedResponse);<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 这里保存到redis</span><br>            wrappedRequest.commitSession();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关注 <code>SessionRepositoryRequestWrapper.getSession()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建了一个session，但是还没有保存到Redis</span><br>S session = SessionRepositoryFilter.<span class="hljs-keyword">this</span>.sessionRepository.createSession();<br><span class="hljs-comment">// wrappedRequest.commitSession() 里面的方法</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commitSession</span><span class="hljs-params">()</span> </span>&#123;<br>    HttpSessionWrapper wrappedSession = getCurrentSession();<br>        <span class="hljs-keyword">if</span> (wrappedSession == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (isInvalidateClientSession()) &#123;<br>                SessionRepositoryFilter.<span class="hljs-keyword">this</span>.httpSessionIdResolver.expireSession(<span class="hljs-keyword">this</span>,<br>                <span class="hljs-keyword">this</span>.response);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            S session = wrappedSession.getSession();<br>            clearRequestedSessionCache();<br>            <span class="hljs-comment">// 在里面保存</span><br>            SessionRepositoryFilter.<span class="hljs-keyword">this</span>.sessionRepository.save(session);<br>            String sessionId = session.getId();<br>        <span class="hljs-keyword">if</span> (!isRequestedSessionIdValid()<br>            || !sessionId.equals(getRequestedSessionId())) &#123;<br>                SessionRepositoryFilter.<span class="hljs-keyword">this</span>.httpSessionIdResolver.setSessionId(<span class="hljs-keyword">this</span>,<br>                <span class="hljs-keyword">this</span>.response, sessionId);<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心保存方法</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveDelta</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.delta.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    String key = getSessionKey(getId());<br>    RedisSessionRepository.<span class="hljs-keyword">this</span>.sessionRedisOperations.opsForHash().putAll(key, <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-keyword">this</span>.delta));<br>    RedisSessionRepository.<span class="hljs-keyword">this</span>.sessionRedisOperations.expireAt(key,<br>            Date.from(Instant.ofEpochMilli(getLastAccessedTime().toEpochMilli())<br>                    .plusSeconds(getMaxInactiveInterval().getSeconds())));<br>    <span class="hljs-keyword">this</span>.delta.clear();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>session</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式id</title>
    <link href="/2021/07/25/global-id/"/>
    <url>/2021/07/25/global-id/</url>
    
    <content type="html"><![CDATA[<p>在数据库集群模式中，往往不能使用自增id，这时候可以在业务端生成全局唯一id。主要的方法有三种</p><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>直接使用jdk提供的UUID，优点是简单，缺点是非自增，无规律</p><h3 id="snowflake算法"><a href="#snowflake算法" class="headerlink" title="snowflake算法"></a>snowflake算法</h3><hr><p><img src="/img/snowflake.png" alt="雪花算法"></p><p>雪花算法主要结构如下</p><ul><li>1 位，不用。二进制中最高位为 1 的都是负数，但是我们生成的 id 一般都使用整数，所以这个最高位固定是<code>0</code></li><li>41 位，用来记录时间戳（毫秒）, 理论上可以支持69年左右</li><li>10 位，用来记录集群id和工作机器id<ul><li>可以部署在 <code>2^10 = 1024</code> 个节点，包括 5 位 datacenterId 和 5 位 workerId</li></ul></li><li>12 位序列号，用来记录同毫秒内产生的不同 id, 一毫秒同一个机器可以产生4096个id</li></ul><p>SnowFlake 可以保证：</p><p>同一台服务器所有生成的 id 按时间趋势递增</p><p>整个分布式系统内不会产生重复 id（因为有 datacenterId 和 workerId 来做区分）</p><p><code>依赖机器时钟，需要做时钟同步</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ntpdate -u ntp.api.bz<br></code></pre></td></tr></table></figure><p>主要的算法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">long</span> <span class="hljs-title">nextId</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> timestamp = timeGen();<br>    <span class="hljs-comment">// 获取当前时间戳如果小于上次时间戳，则表示时间戳获取出现异常</span><br>    <span class="hljs-keyword">if</span> (timestamp &lt; lastTimestamp) &#123;<br>        System.err.printf(<span class="hljs-string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>, lastTimestamp);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(String.format(<span class="hljs-string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>,<br>                lastTimestamp - timestamp));<br>    &#125;<br>    <span class="hljs-comment">// 获取当前时间戳如果等于上次时间戳</span><br>    <span class="hljs-comment">// 说明：还处在同一毫秒内，则在序列号加1；否则序列号赋值为0，从0开始。</span><br>    <span class="hljs-keyword">if</span> (lastTimestamp == timestamp) &#123;<br>        sequence = (sequence + <span class="hljs-number">1</span>) &amp; sequenceMask;<br>        <span class="hljs-comment">// sequence=0表示已经打到了4096，超过了边界，此时需要等待直到下一毫秒</span><br>        <span class="hljs-keyword">if</span> (sequence == <span class="hljs-number">0</span>) &#123;<br>            timestamp = tilNextMillis(lastTimestamp);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        sequence = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//将上次时间戳值刷新</span><br>    lastTimestamp = timestamp;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回结果：</span><br><span class="hljs-comment">     * (timestamp - twepoch) &lt;&lt; timestampLeftShift) 表示将时间戳减去初始时间戳，再左移相应位数</span><br><span class="hljs-comment">     * (datacenterId &lt;&lt; datacenterIdShift) 表示将数据id左移相应位数</span><br><span class="hljs-comment">     * (workerId &lt;&lt; workerIdShift) 表示将工作id左移相应位数</span><br><span class="hljs-comment">     * | 是按位或运算符，例如：x | y，只有当x，y都为0的时候结果才为0，其它情况结果都为1。</span><br><span class="hljs-comment">     * 因为个部分只有相应位上的值有意义，其它位上都是0，所以将各部分的值进行 | 运算就能得到最终拼接好的id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) |<br>            (datacenterId &lt;&lt; datacenterIdShift) |<br>            (workerId &lt;&lt; workerIdShift) |<br>            sequence;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的源码可以参考这里 <a href="https://github.com/jsrdxzw/improve-java/blob/master/id_worker/src/main/java/globalid/IdWorker.java">雪花算法源码</a></p><h3 id="借助Redis的Incr命令获取全局唯⼀ID"><a href="#借助Redis的Incr命令获取全局唯⼀ID" class="headerlink" title="借助Redis的Incr命令获取全局唯⼀ID"></a>借助Redis的Incr命令获取全局唯⼀ID</h3><hr><p>Redis可以保证原子性提供全局id，也是一个推荐的做法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">long</span> id = jedis.incr(<span class="hljs-string">&quot;id&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;从redis中获取的分布式id为：&quot;</span> + id);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != jedis) &#123;<br>            jedis.close();<br>        &#125; <br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU算法</title>
    <link href="/2021/07/23/lru/"/>
    <url>/2021/07/23/lru/</url>
    
    <content type="html"><![CDATA[<p>LRU缓存机制即最少最近使用原则（<code>Least Recently Used</code>的缩写），常见于Redis等内存淘汰机制。也是面试的常考题<br>具体的实现方式是，使用<code>Map + Node</code>双向链表实现，Map可以快速定位Node节点，双向链表方便插入和删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-keyword">private</span> Node head;<br>    <span class="hljs-keyword">private</span> Node tail;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Node&gt; map;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> Node prev;<br>        <span class="hljs-keyword">private</span> Node next;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> key;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;<br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">new</span> Node();<br>        <span class="hljs-keyword">this</span>.tail = <span class="hljs-keyword">new</span> Node();<br>        head.next = tail;<br>        tail.prev = head;<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        Node node = map.get(key);<br>        removeNode(node);<br>        moveHead(node);<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        Node node = map.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 缓存里没有，则需要插入新的节点</span><br>            size++;<br>            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;<br>                <span class="hljs-comment">// 容量已经满了，则需要删除尾节点，并插入新节点</span><br>                Node t = tail.prev;<br>                <span class="hljs-comment">// 删除node</span><br>                map.remove(t.key);<br>                removeNode(t);<br>                size--;<br>            &#125;<br>            node = <span class="hljs-keyword">new</span> Node(key, value);<br>            map.put(key, node);<br>            moveHead(node);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.value = value;<br>            removeNode(node);<br>            moveHead(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveHead</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        <span class="hljs-comment">// 移动节点到头部</span><br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>        node.prev = head;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>面试</tag>
      
      <tag>LRU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一致性Hash算法</title>
    <link href="/2021/07/23/hash/"/>
    <url>/2021/07/23/hash/</url>
    
    <content type="html"><![CDATA[<h3 id="Hash算法使用场景"><a href="#Hash算法使用场景" class="headerlink" title="Hash算法使用场景"></a>Hash算法使用场景</h3><hr><p>Hash算法在分布式领域中有广泛的应用，比如分布式集群架构Redis、Hadoop、ElasticSearch，Mysql分库分表，Nginx负载均衡等</p><ul><li>请求负载均衡(比如nginx的ip_hash策略)</li><li>分布式存储<br>比如根据key做hash取余数，然后请求不同的redis节点</li></ul><h3 id="普通Hash算法"><a href="#普通Hash算法" class="headerlink" title="普通Hash算法"></a>普通Hash算法</h3><hr><p>普通Hash算法存在这样的问题，即如果其中一个节点宕机了，那么hash的结果就不对了，<br>如果后台服务器很多台，客户端也有很多，那么影响是很大的，缩容和扩容都会存在这样的问题。<br><strong>大量用户的请求会被路由到其他的目标服务器处理</strong>，用户在原来服务器中的会话都会丢失。<br>缓存命中率低。</p><h3 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h3><hr><p>一致性Hash算法，保证无论是扩容还是缩容，都只影响一小部分的客户端，并且保证一定的缓存命中率（很多请求还是走的原来的服务节点）。<br>可以增加虚拟节点解决<code>Hash 环数据倾斜的问题</code>，理论上虚拟节点越多分布越均匀</p><h3 id="实现一致性Hash算法"><a href="#实现一致性Hash算法" class="headerlink" title="实现一致性Hash算法"></a>实现一致性Hash算法</h3><hr><p>这里使用<code>TreeMap</code>实现Hash环，hash算法使用默认的<code>hashCode()</code>，如果为了hash均匀，可以采用其他的Hash算法比如<br><code>CRC32_HASH、FNV1_32_HASH、KETAMA_HASH</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsistentHashWithVirtual</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义服务器ip</span><br>        String[] tomcatServers = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;123.111.0.0&quot;</span>, <span class="hljs-string">&quot;123.101.3.1&quot;</span>, <span class="hljs-string">&quot;111.20.35.2&quot;</span>, <span class="hljs-string">&quot;123.98.26.3&quot;</span>&#125;;<br>        <span class="hljs-comment">// hash环用有序Map来模拟</span><br>        <span class="hljs-keyword">final</span> TreeMap&lt;Integer, String&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();<br>        <span class="hljs-comment">// 定义针对每个真实服务器虚拟出来几个节点</span><br>        <span class="hljs-keyword">int</span> virtualCount = <span class="hljs-number">3</span>;<br><br>        <span class="hljs-keyword">for</span> (String tomcatServer : tomcatServers) &#123;<br>            <span class="hljs-comment">// 求出每一个ip的hash值，对应到hash环上，存储hash值与ip的对应关系</span><br>            <span class="hljs-comment">// 直接使用hashCode可能会造成分布不均匀的情况, 可以使用 FNVI_32_HASH 算法</span><br>            <span class="hljs-comment">// 使用 FNVI_32_HASH 算法计算 Hash 值，在服务器增加后，缓存的命中率为 78% 左右</span><br>            <span class="hljs-keyword">int</span> hash = Math.abs(tomcatServer.hashCode());<br>            treeMap.put(hash, tomcatServer);<br><br>            <span class="hljs-comment">// 增加虚拟节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; virtualCount; i++) &#123;<br>                <span class="hljs-comment">// 123.111.0.0#0,123.111.0.0#1,123.111.0.0#2</span><br>                <span class="hljs-keyword">int</span> virtualHash = Math.abs((tomcatServer + <span class="hljs-string">&quot;#&quot;</span> + i).hashCode());<br>                treeMap.put(virtualHash, tomcatServer);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 定义客户端IP</span><br>        String[] clients = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;10.78.12.3&quot;</span>,<span class="hljs-string">&quot;113.25.63.1&quot;</span>,<span class="hljs-string">&quot;126.12.3.8&quot;</span>&#125;;<br><br>        <span class="hljs-keyword">for</span>(String client : clients) &#123;<br>            <span class="hljs-keyword">int</span> hash = Math.abs(client.hashCode());<br>            <span class="hljs-comment">// 向右寻找第一个 key</span><br>            Map.Entry&lt;Integer, String&gt; subEntry = treeMap.ceilingEntry(hash);<br>            <span class="hljs-comment">// 设置成一个环，如果超过尾部，则取第一个点</span><br>            subEntry = subEntry == <span class="hljs-keyword">null</span> ? treeMap.firstEntry() : subEntry;<br>            System.out.println(<span class="hljs-string">&quot;==========&gt;&gt;&gt;&gt;客户端：&quot;</span> + client + <span class="hljs-string">&quot; 被路由到服务器：&quot;</span> + subEntry.getValue());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Nginx配置一致性Hash算法"><a href="#Nginx配置一致性Hash算法" class="headerlink" title="Nginx配置一致性Hash算法"></a>Nginx配置一致性Hash算法</h3><hr><p><code>ngx_http_upstream_consistent_hash</code> 模块是一个负载均衡器，使用一个内部一致性hash算法来选择<br>合适的后端节点。</p><p>该模块可以根据配置参数采取不同的方式将请求均匀映射到后端机器</p><ul><li>consistent_hash $remote_addr:可以根据客户端ip映射</li><li>consistent_hash $request_uri:根据客户端请求的uri映射</li><li>consistent_hash $args:根据客户端携带的参数进行映</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">upstream server &#123;<br>    consistence_hash $$request_uri;<br>    server 127.0.0.1:8080;<br>    server 127.0.0.1:8081;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>一致性Hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typescript高级特性</title>
    <link href="/2021/07/23/ts-union/"/>
    <url>/2021/07/23/ts-union/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Typescript已经是前端工程开发的必备利器和组件库开发的不二之选。<br>在看源码的时候，经常会出现typescript的一些高级特性，比如交叉类型，联合类型和类型保护。适当使用这些特性能帮助我们更好的开发和阅读前端项目。</p><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ObjectConstructor &#123;<br>  assign&lt;T, U&gt;(target: T, <span class="hljs-attr">source</span>: U): T &amp; U;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的是ts的源码，可以看到这里将U拷贝到T类型，返回了T和U的交叉类型</p><p>再举一个简单的例子</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">interface</span> B &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">sayGender</span>: <span class="hljs-function">(<span class="hljs-params">gender: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><br><span class="hljs-keyword">let</span> a: A &amp; B<br><br><span class="hljs-comment">// 都是合法的</span><br>a.age<br>a.sayName<br></code></pre></td></tr></table></figure><p>这里面的a对象继承了接口定义的所有属性</p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型是具有或关系的多个类型组合而成，只要满足其中一个类型即可。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> DateConstructor &#123;<br>  <span class="hljs-keyword">new</span> (value: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">Date</span>): <span class="hljs-built_in">Date</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Date</code>构造函数接受一个number或string或Date类型的参数，对应类型为number | string | Date<br>联合类型A | B要么是A要么是B，因此只有所有源类型的公共成员（“交集”）才能访问。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">interface</span> B &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">sayGender</span>: <span class="hljs-function">(<span class="hljs-params">gender: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><br><span class="hljs-keyword">let</span> a: A | B<br><br><span class="hljs-comment">// 可以访问</span><br>a.name<br><br><span class="hljs-comment">// 不可以访问</span><br>a.age<br>a.sayGender()<br></code></pre></td></tr></table></figure><p>上面的例子中只能访问公共的属性，因为编译器不知道到底是A类型还是B类型，所以只能访问公共的属性。</p><h3 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h3><p>类型保护我的理解是，通过if等条件语句的判断告诉编译器，我知道它的类型了，可以放心调用这种类型的方法，常用的类型保护有<code>typeof</code>类型保护，<code>instanceof</code>类型保护和<strong>自定义类型保护</strong></p><h4 id="typeof类型保护"><a href="#typeof类型保护" class="headerlink" title="typeof类型保护"></a>typeof类型保护</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BuildURL</span>(<span class="hljs-params">param: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">any</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> param.toUpperCase()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的很简单的例子中，由于使用了<code>typeof</code>类型保护，所以在if的分支里可以告诉编译器放心的调用string类型的方法，编译器也会给出自动提示</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BuildURL</span>(<span class="hljs-params">param: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">any</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> param !== <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; param.startsWith(<span class="hljs-string">&quot;xxx&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>结合类型保护编译器会非常的智能，比如上面的例子，编译器知道我们传来的param只有<code>string</code>和<code>number</code>两种类型，由于使用了类型保护，编译器知道param是string类型，所以可以调用startsWith方法。<br>具体的，typeof类型保护能够识别两种形式的typeof：</p><ul><li><code>typeof v === &quot;typename&quot;</code></li><li><code>typeof v !== &quot;typename&quot;</code></li></ul><p>typename只能是number、string、boolean或symbol，因为其余的typeof检测结果不那么可靠，比如</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">any</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>  <span class="hljs-comment">// any类型，typeof类型保护不适用</span><br>  x;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>  <span class="hljs-comment">// any类型，typeof类型保护不适用</span><br>  x;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以有时候我们需要使用自定义方式实现保护类型</p><h3 id="instanceof类型保护"><a href="#instanceof类型保护" class="headerlink" title="instanceof类型保护"></a>instanceof类型保护</h3><p>instanceof类型保护和typeof类型用法相似，它主要是用来判断是否是一个类的对象或者继承对象的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">Date</span> | <span class="hljs-built_in">RegExp</span>;<br><span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) &#123;<br>  <span class="hljs-comment">// 正确 instanceof类型保护，自动对应到RegExp实例类型</span><br>  x.test(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 正确 自动对应到Date实例类型</span><br>  x.getTime();<br>&#125;<br><br><span class="hljs-keyword">interface</span> DateOrRegExp &#123;<br>    <span class="hljs-comment">// 这里表示构造器无参，Date类型的类</span><br>    <span class="hljs-keyword">new</span>(): <span class="hljs-built_in">Date</span>;<br>    <span class="hljs-keyword">new</span>(value?: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">RegExp</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> A: DateOrRegExp;<br><span class="hljs-keyword">let</span> y;<br><span class="hljs-keyword">if</span> (y <span class="hljs-keyword">instanceof</span> A) &#123;<br>    <span class="hljs-comment">// y从any到RegExp | Date</span><br>    y;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义类型保护"><a href="#自定义类型保护" class="headerlink" title="自定义类型保护"></a>自定义类型保护</h3><p>typeof与instanceof类型保护能够满足一般场景，对于一些更加特殊的，可以通过自定义类型保护来对应类型,比如我们自己定义一个请求参数的接口类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> RequestParams &#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>,<br>  onSuccess?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>,<br>  onFailure?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidRequestParams</span>(<span class="hljs-params">request: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">request</span> <span class="hljs-title">is</span> <span class="hljs-title">RequestParams</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> request &amp;&amp; request.url<br>&#125;<br><br><span class="hljs-keyword">let</span> request<br><br><span class="hljs-comment">// 检测客户端发送过来的参数</span><br><span class="hljs-keyword">if</span> (isValidRequestParams(request))&#123;<br>  request.url<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面通过判断，我们需要手动告诉编译器通过isValidRequestParams的判断则request就是RequestParams类型的参数，编译器如何知道这一点呢，我们在这里通过类型谓词<code>parameterName is Type</code>告诉了编译器，isValidRequestParams返回了true则request就是RequestParams类型。<br>其它用法和上面所列举的一致</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> isNumber: <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) =&gt;</span> value is <span class="hljs-built_in">number</span>;<br><br><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">if</span> (isNumber(x)) &#123;<br>  <span class="hljs-comment">// 缩窄到number</span><br>  x.toFixed(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 通过类型保护，编译器知道不是number就是string</span><br>  x.toUpperCase();<br>&#125;<br></code></pre></td></tr></table></figure><p>结合类型保护，编译器会更加的智能，也能极大地降低bug出现的风险。</p><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><ul><li><p>new()类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">c: &#123; <span class="hljs-keyword">new</span>(): T &#125;</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> c()<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello test class&quot;</span>)<br>  &#125;<br>&#125;<br><br>create(Test)<br></code></pre></td></tr></table></figure><p>在typescript中，要实现工厂模式是很容易的，我们只需要先声明一个构造函数的类型参数，它构造出来的是T类型new():T，然后在函数体里面返回c这个类构造出来的对象即可。</p></li><li><p>空类型安全</p></li></ul><p>针对空类型的潜在问题，TypeScript提供了–strictNullChecks选项，开启之后会严格检查空类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">string</span>;<br><span class="hljs-comment">// 错误 Type &#x27;null&#x27; is not assignable to type &#x27;string&#x27;.</span><br>x = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 错误 Type &#x27;undefined&#x27; is not assignable to type &#x27;string&#x27;.</span><br>x = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typescript</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android仿今日头条图片滑动退出效果</title>
    <link href="/2021/07/23/coupon-photo/"/>
    <url>/2021/07/23/coupon-photo/</url>
    
    <content type="html"><![CDATA[<h3 id="Android仿今日头条图片滑动退出效果-Kotlin版"><a href="#Android仿今日头条图片滑动退出效果-Kotlin版" class="headerlink" title="Android仿今日头条图片滑动退出效果-Kotlin版"></a>Android仿今日头条图片滑动退出效果-Kotlin版</h3><p>主要功能:</p><ol><li>在下滑时，随着手指的移动，图片区域跟随移动，并且activity的背景和页码逐渐变的透明</li><li>滑动距离不超过设定的临界值时，会有回弹效果。</li><li>滑动超过设置的临界值时，放开手指，页面滑动退出消失</li><li>图片可以正常放大缩小，页面不跟随手指上下滑动</li><li>使用了共享元素的页面切换效果</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SlideCloseLayout</span></span>(context: Context, attrs: AttributeSet? = <span class="hljs-literal">null</span>) : FrameLayout(context, attrs) &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> previousX: <span class="hljs-built_in">Float</span> = <span class="hljs-number">0f</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> previousY: <span class="hljs-built_in">Float</span> = <span class="hljs-number">0f</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> scrollListener: LayoutScrollListener? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">init</span> &#123;<br>        background?.alpha = <span class="hljs-number">255</span><br>    &#125;<br><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(ev: <span class="hljs-type">MotionEvent</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        ev?.pointerCount?.let &#123;<br>            <span class="hljs-keyword">if</span> (it &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">val</span> y: <span class="hljs-built_in">Float</span> = ev.rawY<br>            <span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Float</span> = ev.rawX<br>            <span class="hljs-keyword">when</span> (ev.action) &#123;<br>                MotionEvent.ACTION_DOWN -&gt; &#123;<br>                    previousX = x<br>                    previousY = y<br>                &#125;<br>                MotionEvent.ACTION_MOVE -&gt; &#123;<br>                    <span class="hljs-keyword">val</span> diffY = y - previousY<br>                    <span class="hljs-keyword">val</span> diffX = x - previousX<br>                    <span class="hljs-keyword">if</span> (diffY &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>                    <span class="hljs-keyword">if</span> (Math.abs(diffX) + <span class="hljs-number">50</span> &lt; Math.abs(diffY)) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(ev: <span class="hljs-type">MotionEvent</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        ev?.let &#123;<br>            <span class="hljs-keyword">val</span> y = ev.rawY<br>            <span class="hljs-keyword">val</span> x = ev.rawX<br>            <span class="hljs-keyword">when</span> (ev.action) &#123;<br>                MotionEvent.ACTION_DOWN -&gt; &#123;<br>                    previousX = x<br>                    previousY = y<br>                &#125;<br>                MotionEvent.ACTION_MOVE -&gt; &#123;<br>                    <span class="hljs-keyword">val</span> diffY = Math.max(y - previousY, <span class="hljs-number">0f</span>)<br>                    translationY = diffY<br>                    <span class="hljs-keyword">val</span> alpha = diffY / height<br>                    <span class="hljs-keyword">this</span>.alpha = <span class="hljs-number">1f</span> - alpha<br>                &#125;<br>                MotionEvent.ACTION_UP -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (Math.abs(translationY) &gt; (height / <span class="hljs-number">4</span>)) &#123;<br>                        layoutExitAnim()<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        layoutRecoverAnim()<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> -&gt; &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(ev)<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(ev)<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setLayoutScrollListener</span><span class="hljs-params">(listener: <span class="hljs-type">LayoutScrollListener</span>)</span></span> &#123;<br>        scrollListener = listener<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">layoutRecoverAnim</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> recoverAnim = ObjectAnimator.ofFloat(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;translationY&quot;</span>, <span class="hljs-keyword">this</span>.translationY, <span class="hljs-number">0f</span>)<br>        recoverAnim.duration = <span class="hljs-number">100</span><br>        recoverAnim.start()<br>        <span class="hljs-keyword">this</span>.alpha = <span class="hljs-number">1f</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">layoutExitAnim</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> exitAnim: ObjectAnimator = ObjectAnimator.ofFloat(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;translationY&quot;</span>, translationY, height.toFloat())<br>        exitAnim.addListener(<span class="hljs-keyword">object</span> : AnimatorListenerAdapter() &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAnimationEnd</span><span class="hljs-params">(animation: <span class="hljs-type">Animator</span>?)</span></span> &#123;<br>                <span class="hljs-keyword">this</span><span class="hljs-symbol">@SlideCloseLayout</span>.alpha = <span class="hljs-number">0f</span><br>                scrollListener?.onLayoutClosed()<br>            &#125;<br>        &#125;)<br>        exitAnim.addUpdateListener &#123;<br>            <span class="hljs-keyword">this</span>.alpha = <span class="hljs-number">1</span> - translationY / height<br>        &#125;<br>        exitAnim.duration = <span class="hljs-number">200</span><br>        exitAnim.start()<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LayoutScrollListener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLayoutClosed</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里自定义了一个Layout，为了能够监听手指滑动的事件</p><p>布局文件只要在这个自定义下嵌套即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br> <br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">jp.hotpepper.android.beauty.hair.application.widget.SlideCloseLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/slide_close_layout&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@color/beauty_text_black&quot;</span>&gt;</span><br> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">android.support.v4.view.ViewPager</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/coupon_photo_view_pager&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center&quot;</span> /&gt;</span><br> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/text_view_current_page&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;bottom|center&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginBottom</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/beauty_text_white&quot;</span> /&gt;</span><br> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/image_view_button_close&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;top|left&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginLeft</span>=<span class="hljs-string">&quot;15dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;25dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/btn_close_circle&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:foreground</span>=<span class="hljs-string">&quot;?android:attr/selectableItemBackground&quot;</span> /&gt;</span><br> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">jp.hotpepper.android.beauty.hair.application.widget.SlideCloseLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这里我们因为使用了自动绑定，所以最外层需要绑定一个Layout</p><p>然后是我们的图片画廊展示类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CouponPhotoViewPagerActivity</span> : <span class="hljs-type">BaseActivity</span></span>() &#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> photoUrls: ArrayList&lt;String&gt; <span class="hljs-keyword">by</span> extra()<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> binding <span class="hljs-keyword">by</span> binding&lt;ActivityCouponPhotoViewPagerBinding&gt;(R.layout.activity_coupon_photo_view_pager)<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewPager: ViewPager <span class="hljs-keyword">by</span> lazy &#123;<br>        binding.couponPhotoViewPager<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> closeImageView: ImageView <span class="hljs-keyword">by</span> lazy &#123;<br>        binding.imageViewButtonClose<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> showCurrentPage: TextView <span class="hljs-keyword">by</span> lazy &#123;<br>        binding.textViewCurrentPage<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> slideCloseLayout: SlideCloseLayout <span class="hljs-keyword">by</span> lazy &#123;<br>        binding.slideCloseLayout<br>    &#125;<br> <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        initComponent()<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initComponent</span><span class="hljs-params">()</span></span> &#123;<br>        activityComponent.inject(<span class="hljs-keyword">this</span>)<br>        viewPager.adapter = CouponPhotoViewPagerAdapter(photoUrls)<br>        viewPager.setTransitionNameCompat(SHARED_ELEMENT_NAME)<br>        showCurrentPage.text = getString(R.string.coupon_photo_view_current_page, <span class="hljs-number">1</span>, photoUrls.size)<br>        initEventListener()<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initEventListener</span><span class="hljs-params">()</span></span> &#123;<br>        closeImageView.setOnClickListener &#123;<br>            finishAfterTransitionCompat()<br>        &#125;<br>        viewPager.addOnPageChangeListener(<span class="hljs-keyword">object</span> : ViewPager.SimpleOnPageChangeListener() &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onPageSelected</span><span class="hljs-params">(p0: <span class="hljs-type">Int</span>)</span></span> &#123;<br>                showCurrentPage.text = getString(R.string.coupon_photo_view_current_page, p0 + <span class="hljs-number">1</span>, photoUrls.size)<br>            &#125;<br>        &#125;)<br><br>        slideCloseLayout.setLayoutScrollListener(<span class="hljs-keyword">object</span> : LayoutScrollListener &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLayoutClosed</span><span class="hljs-params">()</span></span> &#123;<br>                finish()<br>                overridePendingTransition(R.anim.fade_in, R.anim.fade_out)<br>            &#125;<br>        &#125;)<br>    &#125;<br>    <br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> SHARED_ELEMENT_NAME = <span class="hljs-string">&quot;sharedView&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intent</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, photoUrls: <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>: Intent =<br>                Intent(context, CouponPhotoViewPagerActivity::<span class="hljs-keyword">class</span>.java)<br>                        .put(CouponPhotoViewPagerActivity::photoUrls, ArrayList(photoUrls))<br><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transitionOptions</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>, sharedElement: <span class="hljs-type">View</span>)</span></span> = ActivityOptionsCompat.makeSceneTransitionAnimation(activity, sharedElement, SHARED_ELEMENT_NAME).toBundle()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>给这个activity定一个主题，不然在下滑的时候是不能透明的，也看不到之前的activity</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;SlideCloseTheme&quot;</span>&gt;</span><span class="xml"></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;windowNoTitle&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowFullscreen&quot;</span>&gt;</span>?android:windowNoTitle<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowIsTranslucent&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowBackground&quot;</span>&gt;</span>@android:color/transparent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowNoTitle&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个主题表示activity是全屏显示并且可以透明化的。</p><p>然后，在manifest.xml中应用这个主题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.application.activity.CouponPhotoViewPagerActivity&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:configChanges</span>=<span class="hljs-string">&quot;orientation&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:screenOrientation</span>=<span class="hljs-string">&quot;portrait&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/SlideCloseTheme&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>实现效果还是很不错的。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx的那些事儿</title>
    <link href="/2021/07/22/nginx/"/>
    <url>/2021/07/22/nginx/</url>
    
    <content type="html"><![CDATA[<p>Nginx是一个高并发，低内存占用的web服务器，单机可以达到5wQPS以上，并且内存占用非常低</p><h3 id="nginx常用命令"><a href="#nginx常用命令" class="headerlink" title="nginx常用命令"></a>nginx常用命令</h3><ul><li>nginx主要命令<ul><li><code>./nginx</code> 启动nginx</li><li><code>./nginx -s stop</code> 终止nginx(当然也可以找到nginx进程号，然后使用kill -9 杀掉nginx进程)</li><li><code>./nginx -s reload</code> (重新加载nginx.conf配置文件)</li></ul></li></ul><h3 id="nginx核心配置"><a href="#nginx核心配置" class="headerlink" title="nginx核心配置"></a>nginx核心配置</h3><p>nginx的配置分为<em>全局块</em>、<em>events块</em>、<em>http块</em></p><h4 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h4><p>从配置文件开始到events块之间的内容，此处的配置影响nginx服务器整体的运行，比如worker进 程的数量、错误日志的位置等</p><h4 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h4><p>events块主要影响nginx服务器与用户的网络连接，比如worker_connections为1024，表示每个<br>worker process 支持的最大连接数为1024</p><h4 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h4><p>http块是配置最频繁的部分，如虚拟主机的配置，监听端口的配置，请求转发、反向代理、负载均衡等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs text"><br>#user  nobody;<br># worker进程数量，即工作进程，通常设置=cpu数量<br>worker_processes  1;<br># 全局错误日志和pid文件位置<br>#error_log  logs/error.log;<br>#error_log  logs/error.log  notice;<br>#error_log  logs/error.log  info;<br><br>#pid        logs/nginx.pid;<br><br># events模块，影响nginx服务器和用户的网络连接<br>events &#123;<br>    # 单个worker连接的最大并发连接数<br>    # 总处理量 = worker_processes * worker_connections<br>    worker_connections  1024;<br>&#125;<br><br><br>http &#123;<br>    include       mime.types;<br>    default_type  application/octet-stream;<br><br>    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;<br>    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;<br>    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;<br><br>    #access_log  logs/access.log  main;<br><br>    sendfile        on;<br>    #tcp_nopush     on;<br><br>    #keepalive_timeout  0;<br>    # 连接超时时间<br>    keepalive_timeout  65;<br><br>    # 压缩<br>    #gzip  on;<br><br>    server &#123;<br>        # 监听的端口<br>        listen       80;<br>        # 虚拟主机 www.xxx.com<br>        server_name  localhost;<br><br>        #charset koi8-r;<br><br>        #access_log  logs/host.access.log  main;<br><br>        # 默认请求<br>        # tomcat context<br>        location / &#123;<br>            root   html; # 网站的根目录<br>            index  index.html index.htm;<br>        &#125;<br><br>        #error_page  404              /404.html;<br><br>        # redirect server error pages to the static page /50x.html<br>        #<br>        error_page   500 502 503 504  /50x.html;<br>        location = /50x.html &#123;<br>            root   html;<br>        &#125;<br><br>        # proxy the PHP scripts to Apache listening on 127.0.0.1:80<br>        #<br>        #location ~ \.php$ &#123;<br>        #    proxy_pass   http://127.0.0.1;<br>        #&#125;<br><br>        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000<br>        #<br>        #location ~ \.php$ &#123;<br>        #    root           html;<br>        #    fastcgi_pass   127.0.0.1:9000;<br>        #    fastcgi_index  index.php;<br>        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;<br>        #    include        fastcgi_params;<br>        #&#125;<br><br>        # deny access to .htaccess files, if Apache&#x27;s document root<br>        # concurs with nginx&#x27;s one<br>        #<br>        #location ~ /\.ht &#123;<br>        #    deny  all;<br>        #&#125;<br>    &#125;<br><br><br>    # another virtual host using mix of IP-, name-, and port-based configuration<br>    #<br>    #server &#123;<br>    #    listen       8000;<br>    #    listen       somename:8080;<br>    #    server_name  somename  alias  another.alias;<br><br>    #    location / &#123;<br>    #        root   html;<br>    #        index  index.html index.htm;<br>    #    &#125;<br>    #&#125;<br><br><br>    # HTTPS server<br>    #<br>    #server &#123;<br>    #    listen       443 ssl;<br>    #    server_name  localhost;<br><br>    #    ssl_certificate      cert.pem;<br>    #    ssl_certificate_key  cert.key;<br><br>    #    ssl_session_cache    shared:SSL:1m;<br>    #    ssl_session_timeout  5m;<br><br>    #    ssl_ciphers  HIGH:!aNULL:!MD5;<br>    #    ssl_prefer_server_ciphers  on;<br><br>    #    location / &#123;<br>    #        root   html;<br>    #        index  index.html index.htm;<br>    #    &#125;<br>    #&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>比如 xxx.com/abc -&gt; tomcat 8080, xxx.com/def -&gt; tomcat 8081</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">server &#123;<br>        listen       80;<br>        server_name  localhost;<br>        #charset koi8-r;<br>        #access_log  logs/host.access.log  main;<br> <br>        location /abc &#123;<br>            proxy_pass   http://127.0.0.1:8080;<br>        &#125;<br>        <br>        location /def &#123;<br>            http://127.0.0.1:8081;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>相同请求会分发到不同的服务器上，降低单个节点的请求压力</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text"># 配置集群的信息, 默认是轮询策略, weight值越大越有可能被分配到<br>upstream xxxServer &#123;<br>    server 127.0.0.1:8080 max_fails=3 fail_timeout=3s weight=2;<br>    server 127.0.0.1:8082;<br>&#125;<br>server &#123;<br>        listen       80;<br>        server_name  localhost;<br>        #charset koi8-r;<br>        #access_log  logs/host.access.log  main;<br> <br>        location /abc &#123;<br>            proxy_pass   http://xxxServer;<br>        &#125;<br>        <br>        location /def &#123;<br>            proxy_pass http://127.0.0.1:8081;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h4><ul><li>轮询<br>默认策略，每个请求按时间顺序逐一分配到不同的服务器，如果某一个服务器下线，能自动剔除</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">upstream xxxServer&#123;<br>    server 111.229.248.243:8080; <br>    server 111.229.248.243:8082;<br>&#125;<br>location /abc &#123;<br>    proxy_pass http://xxxServer;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>weight<br>weight代表权重，默认每一个负载的服务器都为1，权重越高那么被分配的请求越多(用于服务器性能不均衡的场景)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">upstream xxxServer&#123;<br>    server 111.229.248.243:8080 weight=1; <br>    server 111.229.248.243:8082 weight=2;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ip_hash<br>每个请求按照ip的hash结果分配，每一个客户端的请求会固定分配到同一个目标服务器处理，可以解决session问题</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">upstream xxxServer&#123; <br>    ip_hash;<br>    server 111.229.248.243:8080;<br>    server 111.229.248.243:8082; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>Nginx在静态资源请求上性能较好，业务处理交给Tomcat，实现动静分离。<br>Nginx实现静态资源配置也很容易，只需要将静态资源文件放到<em>Nginx服务器</em>上，在配置文件上修改即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">location /static/ &#123;<br>    # nginx服务器目录加载，需要自己创建<br>    root staticDir;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Nginx底层进程机制"><a href="#Nginx底层进程机制" class="headerlink" title="Nginx底层进程机制"></a>Nginx底层进程机制</h4><p>Nginx启动后，以daemon多进程方式在后台运行，包括一个Master进程和多个Worker进程，Master<br>进程负责管理和监控Worker进程，Worker进程负责处理具体的请求。</p><ul><li>master进程 主要是管理worker进程，比如:<ul><li>接收外界信号向各worker进程发送信号(./nginx -s reload)</li><li>监控worker进程的运行状态，当worker进程异常退出后Master进程会自动重新启动新的worker进程</li></ul></li><li>worker进程worker进程具体处理网络请求。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。<br>nginx使用互斥锁来保证只有一个worker进程能够处理请求</li></ul><p>多进程机制的好处：</p><ul><li>一个进程挂了，其他进程可以照样提供服务</li><li>为热部署提供支撑，主要就是reload配置文件的时候，不会影响到旧请求的处理</li></ul><h4 id="nginx信号处理"><a href="#nginx信号处理" class="headerlink" title="nginx信号处理"></a>nginx信号处理</h4><p>以 <code>./nginx -s reload</code> 来说明nginx信号处理这部分 </p><ol><li>master进程对配置文件进行语法检查 </li><li>尝试配置(比如修改了监听端口，那就尝试分配新的监听端口) </li><li>尝试成功则使用新的配置，<strong>新建worker进程</strong> </li><li>新建成功，给旧的worker进程发送关闭消息 </li><li>旧的worker进程收到信号会<strong>继续服务</strong>，直到把当前进程接收到的请求处理完毕后关闭 所以reload之后worker进程pid是发生了变化的</li></ol>]]></content>
    
    
    <categories>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2021/07/22/quick-sort/"/>
    <url>/2021/07/22/quick-sort/</url>
    
    <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>经典的快速排序使用了分治的思想，平均复杂度为O(nlgn)，最坏的情况会退化为O(n^2)</p><p>快排的核心思想就是，找到一个点，先把比它小的排在左边，比它大的排在右边，然后一直递归排下去</p><p><a href="https://leetcode-cn.com/problems/sort-an-array/">Leetcode 912</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortArray(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        partition(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> pivot = nums[left]; <span class="hljs-comment">// 比较值</span><br>        <span class="hljs-keyword">int</span> j = left; <span class="hljs-comment">// 分界点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left + <span class="hljs-number">1</span>; i &lt;= right; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; pivot) &#123;<br>                j++;<br>                swap(nums, i, j);<br>            &#125;<br>        &#125;<br>        swap(nums, left, j);<br>        partition(nums, j + <span class="hljs-number">1</span>, right);<br>        partition(nums, left, j - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> tmp = nums[j];<br>        nums[j] = nums[i];<br>        nums[i] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="加上随机因子的快速排序"><a href="#加上随机因子的快速排序" class="headerlink" title="加上随机因子的快速排序"></a>加上随机因子的快速排序</h3><p>为了避免出现最坏的情况O(n^2)，我们可以引入随机因子，即在每一次分治的步骤中都加上随机的<strong>pivot</strong>，并交换位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 加上随机因子，ran表示的是随机的位置</span><br>        <span class="hljs-keyword">int</span> ran = random.nextInt(right - left + <span class="hljs-number">1</span>) + left;<br>        swap(nums, left, ran);<br>        <span class="hljs-keyword">int</span> pivot = nums[left]; <span class="hljs-comment">// 比较值</span><br>        <span class="hljs-keyword">int</span> j = left; <span class="hljs-comment">// 分界点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left + <span class="hljs-number">1</span>; i &lt;= right; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; pivot) &#123;<br>                j++;<br>                swap(nums, i, j);<br>            &#125;<br>        &#125;<br>        swap(nums, left, j);<br>        partition(nums, j + <span class="hljs-number">1</span>, right);<br>        partition(nums, left, j - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><p>和快速排序类似，快速选择不需要全部排完，只需要对K个元素排好序，然后取K个元素即可</p><p><a href="https://leetcode-cn.com/problems/smallest-k-lcci/">Leetcode 最小的K个数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] smallestK(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;<br>        partition(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k);<br>        <span class="hljs-keyword">return</span> Arrays.copyOfRange(arr, <span class="hljs-number">0</span>, k);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> j = l;<br>        <span class="hljs-keyword">int</span> pivot = arr[l];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = j + <span class="hljs-number">1</span>; i &lt;= r; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; pivot) &#123;<br>                j++;<br>                swap(arr, i, j);<br>            &#125;<br>        &#125;<br>        swap(arr, l, j);<br>        <span class="hljs-keyword">if</span> (j == k) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &lt; k) &#123;<br>            partition(arr, j + <span class="hljs-number">1</span>, r, k);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            partition(arr, l, j - <span class="hljs-number">1</span>, k);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> tmp = arr[j];<br>        arr[j] = arr[i];<br>        arr[i] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/">Leetcode 最接近原点的 K 个点</a><br>这道题把比较的值替换为到原点的距离，其他的解题思路是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] kClosest(<span class="hljs-keyword">int</span>[][] points, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (points.length &lt;= k) &#123;<br>            <span class="hljs-keyword">return</span> points;<br>        &#125;<br>        quickSelect(points, <span class="hljs-number">0</span>, points.length - <span class="hljs-number">1</span>, k);<br>        <span class="hljs-keyword">return</span> Arrays.copyOfRange(points, <span class="hljs-number">0</span>, k);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pivot = distance(points[start]);<br>        <span class="hljs-keyword">int</span> j = start;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start + <span class="hljs-number">1</span>; i &lt;= end; i++) &#123;<br>            <span class="hljs-keyword">if</span> (distance(points[i]) &lt; pivot) &#123;<br>                j++;<br>                swap(points, i, j);<br>            &#125;<br>        &#125;<br>        swap(points, start, j);<br>        <span class="hljs-keyword">if</span> (j == k) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &lt; k) &#123;<br>            quickSelect(points, j + <span class="hljs-number">1</span>, end, k);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            quickSelect(points, start, j - <span class="hljs-number">1</span>, k);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] point)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> point[<span class="hljs-number">0</span>] * point[<span class="hljs-number">0</span>] + point[<span class="hljs-number">1</span>] * point[<span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] tmp = points[i];<br>        points[i] = points[j];<br>        points[j] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>面试</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
